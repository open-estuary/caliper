<testname=ltpacpi.sh>
	<description>
		ACPI (Advanced Control Power & Integration) testscript for 2.5 kernels.

	<\description>
	<test_location>
		ltp/testcases/kernel/device-drivers/acpi/ltpacpi.sh
	<\test_location>
<\testname>
<testname=growfiles>
	<description>
		This program will grow a list of files.
		Each file will grow by grow_incr before the same
		file grows twice. Each file is open and closed before next file is opened.

	<\description>
	<test_location>
		ltp/testcases/kernel/fs/doio/growfiles.c
	<\test_location>
<\testname>
<testname=rwtest>
	<description>
		A wrapper for doio and iogen.

	<\description>
	<test_location>
	<\test_location>
<\testname>
<testname=doio>
	<description>
		a general purpose io initiator with system call and
		write logging. See doio.h for the structure which defines
		what doio requests should look like.

		Currently doio can handle read,write,reada,writea,ssread,
		sswrite, and many varieties of listio requests.
		For disk io, if the O_SSD flag is set doio will allocate
		the appropriate amount of ssd and do the transfer

		thus, doio
		can handle all of the primitive types of file io.

	<\description>
	<test_location>
		ltp/testcases/kernel/fs/doio/doio.c
	<\test_location>
<\testname>
<testname=iogen>
	<description>
		a tool for generating file/sds io for a doio process

	<\description>
	<test_location>
		ltp/testcases/kernel/fs/doio/iogen.c
	<\test_location>
<\testname>
<testname=fs_di>
	<description>
		A FileSystem Data Integrity test.

	<\description>
	<test_location>
		ltp/testcases/kernel/fs/fs_di
	<\test_location>
<\testname>
<testname=fs_inod>
	<description>
		Rapidly creates and deletes files through
		multiple processes running in the background.
		The user may specify the number of subdirectories
		to create, the number of files to create (per
		subdirectory), and the number of times to repeat
		the creation/deletion cycle.

	<\description>
	<test_location>
		ltp/testcases/kernel/fs/fs_inod
	<\test_location>
<\testname>
<testname=fs_maim>
	<description>
		Collection of smaller scripts to stress storage management
		utilities.

	<\description>
	<test_location>
		ltp/testcases/kernel/fs/fs_maim
	<\test_location>
<\testname>
<testname=fs_perms>
	<description>
		Regression test for Linux filesystem permissions.

	<\description>
	<test_location>
		ltp/testcases/kernel/fs/fs_perms/fs_perms.c
	<\test_location>
<\testname>
<testname=fsstress>
	<description>
		A highly configurable stress test utility that calls most of the main
		file system syscalls. Originally developed by SGI for XFS testing.

	<\description>
	<test_location>
		ltp/testcases/kernel/fs/fsstress/fsstress.c
	<\test_location>
<\testname>
<testname=fsx-linux>
	<description>
		Filesystem stress test developed by Apple Computer, Inc.

	<\description>
	<test_location>
		ltp/testcases/kernel/fs/fsx-linux/fsx-linux.c
	<\test_location>
<\testname>
<testname=ftest>
	<description>
		A collection of file system tests developed by Sequent/IBM.

	<\description>
	<test_location>
		ltp/testcases/kernel/fs/ftest
	<\test_location>
<\testname>
<testname=inode>
	<description>
		Inode-based stress tests.

	<\description>
	<test_location>
		ltp/testcases/kernel/fs/inode
	<\test_location>
<\testname>
<testname=lftest>
	<description>
		The purpose of this test is to verify the file size limitations of a filesystem.
		It writes one buffer at a time and lseeks from the beginning of the file to the
		end of the last write position. The intent is to test lseek64.

	<\description>
	<test_location>
		ltp/testcases/kernel/fs/lftest/lftest.c
	<\test_location>
<\testname>
<testname=linktest>
	<description>
		Regression test for max links per file

	<\description>
	<test_location>
		ltp/testcases/kernel/fs/linktest
	<\test_location>
<\testname>
<testname=openfile>
	<description>
		Creates files and opens simultaneously

	<\description>
	<test_location>
		ltp/testcases/kernel/fs/openfile/openfile.c
	<\test_location>
<\testname>
<testname=proc>
	<description>
		Recursively reads all files within /proc filesystem.

	<\description>
	<test_location>
		ltp/testcases/kernel/fs/proc
	<\test_location>
<\testname>
<testname=stream>
	<description>
		Collection of tests for testing stream functions.

	<\description>
	<test_location>
		ltp/testcases/kernel/fs/stream
	<\test_location>
<\testname>
<testname=aio>
	<description>
		Collection of asynchronous i/o tests.

	<\description>
	<test_location>
		ltp/testcases/kernel/io/aio
	<\test_location>
<\testname>
<testname=direct_io>
	<description>
		Collection of direct i/o tests.

	<\description>
	<test_location>
		ltp/testcases/kernel/io/direct_io
	<\test_location>
<\testname>
<testname=disktest>
	<description>
		Does repeated accesses to a filespec and optionally writes to, reads from,
		and verifies the data. By default, disktest makes assumptions about
		the running environment which allows for a quick start of IO generation.
		However, Disktest has a large number of command line options which can
		be used to adapt the test for a variety of uses including data integrity,
		medium integraty, performance, and simple application simulation.

	<\description>
	<test_location>
		ltp/testcases/kernel/io/disktest
	<\test_location>
<\testname>
<testname=stress_cd>
	<description>
		Creates multiple read threads on the cdrom device.

	<\description>
	<test_location>
		ltp/testcases/kernel/io/stress_cd/stress_cd.c
	<\test_location>
<\testname>
<testname=stress_floppy>
	<description>
		Tests the reading/writing/formatting on a floppy drive.

	<\description>
	<test_location>
		ltp/testcases/kernel/io/stress_floppy
	<\test_location>
<\testname>
<testname=ipc_stress>
	<description>
		A collection of tests designed to stress IPC.

	<\description>
	<test_location>
		ltp/testcases/kernel/ipc/ipc_stress
	<\test_location>
<\testname>
<testname=pipeio>
	<description>
		This tool can be used to beat on system or named pipes.
		See the help() function below for user information.

	<\description>
	<test_location>
		ltp/testcases/kernel/ipc/pipeio/pipeio.c
	<\test_location>
<\testname>
<testname=sem01>
	<description>
		Creates a semaphore and two processes. The processes
		each go through a loop where they semdown, delay for a
		random amount of time, and semup, so they will almost
		always be fighting for control of the semaphore.

	<\description>
	<test_location>
		ltp/testcases/kernel/ipc/semaphore/sem01.c
	<\test_location>
<\testname>
<testname=sem02>
	<description>
		The application creates several threads using pthread_create().
		One thread performs a semop() with the SEM_UNDO flag set. The
		change in sempaphore value performed by that semop should be
		"undone" only when the last pthread exits.

	<\description>
	<test_location>
		ltp/testcases/kernel/ipc/semaphore/sem02.c
	<\test_location>
<\testname>
<testname=libmm>
	<description>
		Tests the libmm core API.

	<\description>
	<test_location>
		ltp/testcases/kernel/mem/libmm
	<\test_location>
<\testname>
<testname=mem01>
	<description>
		Test for exercising virtual memory allocation
		and usage. It is intended to provide a limited exposure of the
		system swapper, for now.

	<\description>
	<test_location>
		ltp/testcases/kernel/mem/mem/mem01.c
	<\test_location>
<\testname>
<testname=mem02>
	<description>
		Checks that memory can be allocated and freed.

	<\description>
	<test_location>
		ltp/testcases/kernel/mem/mem/mem02.c
	<\test_location>
<\testname>
<testname=mmapstress>
	<description>
		A group of tests for testing mmap().

	<\description>
	<test_location>
		ltp/testcases/kernel/mem/mmapstress
	<\test_location>
<\testname>
<testname=mtest01>
	<description>
		mallocs memory <chunksize> at a time until malloc fails.

	<\description>
	<test_location>
		ltp/testcases/kernel/mem/mtest01/mtest01.c
	<\test_location>
<\testname>
<testname=mmstress>
	<description>
		Performs General Stress with Race conditions

	<\description>
	<test_location>
		ltp/testcases/kernel/mem/mtest05/mmstress.c
	<\test_location>
<\testname>
<testname=mmap1>
	<description>
		Test the LINUX memory manager. The program is aimed at
		stressing the memory manager by simultanious map/unmap/read
		by light weight processes, the test is scheduled to run for
		a mininum of 24 hours.

	<\description>
	<test_location>
		ltp/testcases/kernel/mem/mtest06/mmap1.c
	<\test_location>
<\testname>
<testname=mmap2>
	<description>
		Test the LINUX memory manager. The program is aimed at
		stressing the memory manager by repeaded map/write/unmap of a
		of a large gb size file.

	<\description>
	<test_location>
		ltp/testcases/kernel/mem/mtest06/mmap2.c
	<\test_location>
<\testname>
<testname=mmap3>
	<description>
		Test the LINUX memory manager. The program is aimed at
		stressing the memory manager by repeaded map/write/unmap
		of file/memory of random size (maximum 1GB) this is done by
		multiple processes.

	<\description>
	<test_location>
		ltp/testcases/kernel/mem/mtest06/mmap3.c
	<\test_location>
<\testname>
<testname=shmat1>
	<description>
		Test the LINUX memory manager. The program is aimed at
		stressing the memory manager by repeaded shmat/write/read/
		shmatd of file/memory of random size (maximum 1000 * 4096)
		done by multiple processes.

	<\description>
	<test_location>
		ltp/testcases/kernel/mem/mtest06/shmat1.c
	<\test_location>
<\testname>
<testname=mallocstress>
	<description>
		Stresses the VMM and C library by spawning N threads which
		malloc blocks of increasing size until malloc returns NULL.

	<\description>
	<test_location>
		ltp/testcases/kernel/mem/mtest07/mallocstress.c
	<\test_location>
<\testname>
<testname=shm_test>
	<description>
		Stresses memory management subsystem of Linux. Spawns multiple
		pairs of reader & writer threads. One thread will create the
		shared segment of random size and write to this memory, the
		other pair will read from this memory.

	<\description>
	<test_location>
		ltp/testcases/kernel/mem/mtest07/shm_test.c
	<\test_location>
<\testname>
<testname=page>
	<description>
		Tests the behavior of memory paging.

	<\description>
	<test_location>
		ltp/testcases/kernel/mem/page
	<\test_location>
<\testname>
<testname=shmt>
	<description>
		A collection of shared memory tests.

	<\description>
	<test_location>
		ltp/testcases/kernel/mem/shmt
	<\test_location>
<\testname>
<testname=vmtests>
	<description>
		Data and stack space VM tests.

	<\description>
	<test_location>
		ltp/testcases/kernel/mem/vmtests
	<\test_location>
<\testname>
<testname=create_module>
	<description>
		Tests the basic functionality of create_module().

	<\description>
	<test_location>
		ltp/testcases/kernel/module/create_module
	<\test_location>
<\testname>
<testname=delete_module>
	<description>
		Tests the basic functionality of delete_module().

	<\description>
	<test_location>
		ltp/testcases/kernel/module/delete_module
	<\test_location>
<\testname>
<testname=query_module>
	<description>
		Tests the basic functionality of query_module().

	<\description>
	<test_location>
		ltp/testcases/kernel/module/query_module
	<\test_location>
<\testname>
<testname=hangup01>
	<description>
		Writes three messages to a slave pty, with a hangup after each.
		Verifies all thre messages are received.

	<\description>
	<test_location>
		ltp/testcases/kernel/pty/hangup01.c
	<\test_location>
<\testname>
<testname=ptem01>
	<description>
		- Tests termio/termios ioctls
		- Tests window size setting and getting
		- Tests sending a break
		- Tests multiple opens of slave side
		- Tests several simultaneous opens

	<\description>
	<test_location>
		ltp/testcases/kernel/pty/ptem01.c
	<\test_location>
<\testname>
<testname=pty01>
	<description>
		- Tests slave locking
		- Tests slave operations with closed master
		- Tests operations on master with closed slave
		- Tests multiple opens on slave side of pty
		- Tests opening/closing of lots of ptys in parallel.

	<\description>
	<test_location>
		ltp/testcases/kernel/pty/pty01.c
	<\test_location>
<\testname>
<testname=clisrv>
	<description>
		Read contents of data file. Write each line to socket, then
		read line back from socket and write to standard output.

	<\description>
	<test_location>
		ltp/testcases/kernel/sched/clisrv
	<\test_location>
<\testname>
<testname=ht_enabled>
	<description>
		Test for whether HT enabling is the default setting and
		the kernel option works as expected.

	<\description>
	<test_location>
		ltp/testcases/kernel/sched/hyperthreading/ht_enabled
	<\test_location>
<\testname>
<testname=ht_affinity>
	<description>
		Test for whether a set of system calls is provided to bind
		itself or another process to a subset of currently active
		processors and to get affinity information.

	<\description>
	<test_location>
		ltp/testcases/kernel/sched/hyperthreading/ht_affinity
	<\test_location>
<\testname>
<testname=ht_interrupt>
	<description>
		Test for SMP interrupt distribution among all logical CPU
		should not be interfered by HT patch.

	<\description>
	<test_location>
		ltp/testcases/kernel/sched/hyperthreading/ht_interrupt
	<\test_location>
<\testname>
<testname=process_stress>
	<description>
		Stresses the process management kernel code.

	<\description>
	<test_location>
		ltp/testcases/kernel/sched/process_stress
	<\test_location>
<\testname>
<testname=pth_str01>
	<description>
		Creates a tree of threads

	<\description>
	<test_location>
		ltp/testcases/kernel/sched/pthreads/pth_str01.c
	<\test_location>
<\testname>
<testname=pth_str02>
	<description>
		Creates n threads

	<\description>
	<test_location>
		ltp/testcases/kernel/sched/pthreads/pth_str02.c
	<\test_location>
<\testname>
<testname=pth_str03>
	<description>
		Creates a tree of threads does calculations, and
		returns result to parent

	<\description>
	<test_location>
		ltp/testcases/kernel/sched/pthreads/pth_str03.c
	<\test_location>
<\testname>
<testname=sched_stress>
	<description>
		Stress the scheduler code of the kernel.

	<\description>
	<test_location>
		ltp/testcases/kernel/sched/sched_stress
	<\test_location>
<\testname>
<testname=time-schedule>
	<description>
		Tool to test how long a context switch takes.

	<\description>
	<test_location>
		ltp/testcases/kernel/sched/tool/time-schedule.c
	<\test_location>
<\testname>
<testname=trace_sched>
	<description>
		This utility spawns N tasks, each task sets its priority by
		making a system call to the scheduler. The thread function
		reads the priority that tbe schedular sets for this task and
		also reads from /proc the processor this task last executed on
		the information that is gathered by the thread function may
		be in real-time. Its only an approximation.

	<\description>
	<test_location>
		ltp/testcases/kernel/sched/tool/trace_sched.c
	<\test_location>
<\testname>
<testname=abort01>
	<description>
		Basic test for abort(3).

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/abort/abort01.c
	<\test_location>
<\testname>
<testname=accept01>
	<description>
		Verify that accept() returns the proper errno for various failure cases

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/accept/accept01.c
	<\test_location>
<\testname>
<testname=access01>
	<description>
		Basic test for access(2) using F_OK, R_OK, W_OK, and X_OK arguments.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/access/access01.c
	<\test_location>
<\testname>
<testname=access02>
	<description>
		Verify that access() succeeds to check the read/write/execute permissions
		on a file if the mode argument passed was R_OK/W_OK/X_OK.

		Also verify that, access() succeeds to test the accessibility of the file
		referred to by symbolic link if the pathname points to a symbolic link.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/access/access02.c
	<\test_location>
<\testname>
<testname=access03>
	<description>
		EFAULT error testing for access(2).

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/access/access03.c
	<\test_location>
<\testname>
<testname=access04>
	<description>
		Verify that,
		1. access() fails with -1 return value and sets errno to EACCES
		if the permission bits of the file mode do not permit the
		requested (Read/Write/Execute) access.
		2. access() fails with -1 return value and sets errno to EINVAL
		if the specified access mode argument is invalid.
		3. access() fails with -1 return value and sets errno to EFAULT
		if the pathname points outside allocate address space for the
		process.
		4. access() fails with -1 return value and sets errno to ENOENT
		if the specified file doesn't exist (or pathname is NULL).
		5. access() fails with -1 return value and sets errno to ENAMETOOLONG
		if the pathname size is > PATH_MAX characters.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/access/access04.c
	<\test_location>
<\testname>
<testname=access05>
	<description>
		Verify that access() succeeds to check the existance of a file if
		search access is permitted on the pathname of the specified file.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/access/access05.c
	<\test_location>
<\testname>
<testname=acct01>
	<description>
		Issues calls to acct() and tests the returned values against expected
		results

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/acct/acct01.c
	<\test_location>
<\testname>
<testname=adjtimex01>
	<description>
		Basic test for adjtimex().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/adjtimex/adjtimex01.c
	<\test_location>
<\testname>
<testname=adjtimex02>
	<description>
		Tests for error conditions.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/adjtimex/adjtimex02.c
	<\test_location>
<\testname>
<testname=alarm01>
	<description>
		Basic test for alarm(2).

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/alarm/alarm01.c
	<\test_location>
<\testname>
<testname=alarm02>
	<description>
		Boundary Value Test for alarm(2).

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/alarm/alarm02.c
	<\test_location>
<\testname>
<testname=alarm03>
	<description>
		Alarm(2) cleared by a fork.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/alarm/alarm03.c
	<\test_location>
<\testname>
<testname=alarm04>
	<description>
		Check that when an alarm request is made, the signal SIGALRM is received
		even after the process has done an exec().

	<\description>
	<test_location>
	<\test_location>
<\testname>
<testname=alarm05>
	<description>
		Check the functionality of the Alarm system call when the time input
		parameter is non zero.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/alarm/alarm05.c
	<\test_location>
<\testname>
<testname=alarm06>
	<description>
		Check the functionality of the Alarm system call when the time input
		parameter is zero.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/alarm/alarm06.c
	<\test_location>
<\testname>
<testname=alarm07>
	<description>
		Check the functionality of the alarm() when the time input
		parameter is non-zero and the process does a fork.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/alarm/alarm07.c
	<\test_location>
<\testname>
<testname=asyncio02>
	<description>
		Write/close flushes data to the file.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/asyncio/asyncio02.c
	<\test_location>
<\testname>
<testname=bind01>
	<description>
		Verify that bind() returns the proper errno for various failure cases

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/bind/bind01.c
	<\test_location>
<\testname>
<testname=brk01>
	<description>
		Test the basic functionality of brk().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/brk/brk01.c
	<\test_location>
<\testname>
<testname=capget01>
	<description>
		Test the basic functionality of capget().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/capget/capget01.c
	<\test_location>
<\testname>
<testname=capget02>
	<description>
		Test the error conditions of capget().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/capget/capget02.c
	<\test_location>
<\testname>
<testname=capset01>
	<description>
		Test the basic functionality of capset().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/capset/capset01.c
	<\test_location>
<\testname>
<testname=capset02>
	<description>
		Test the error conditions of capset().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/capset/capset02.c
	<\test_location>
<\testname>
<testname=chdir01>
	<description>
		Check proper operation of chdir(): tests whether the
		system call can it change the current, working directory, and find a
		file there? Will it fail on a non-directory entry ?

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/chdir/chdir01.c
	<\test_location>
<\testname>
<testname=chdir02>
	<description>
		Basic test for chdir(2).

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/chdir/chdir02.c
	<\test_location>
<\testname>
<testname=chdir03>
	<description>
		Testcase for testing that chdir(2) sets EACCES errno

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/chdir/chdir03.c
	<\test_location>
<\testname>
<testname=chdir04>
	<description>
		Testcase to test whether chdir(2) sets errno correctly.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/chdir/chdir04.c
	<\test_location>
<\testname>
<testname=chmod01>
	<description>
		Verify that, chmod(2) succeeds when used to change the mode permissions
		of a file.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/chmod/chmod01.c
	<\test_location>
<\testname>
<testname=chmod02>
	<description>
		Basic test for chmod(2).

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/chmod/chmod02.c
	<\test_location>
<\testname>
<testname=chmod03>
	<description>
		Verify that, chmod(2) will succeed to change the mode of a file
		and set the sticky bit on it if invoked by non-root (uid != 0)
		process with the following constraints,
		- the process is the owner of the file.
		- the effective group ID or one of the supplementary group ID's of the
		process is equal to the group ID of the file.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/chmod/chmod03.c
	<\test_location>
<\testname>
<testname=chmod04>
	<description>
		Verify that, chmod(2) will succeed to change the mode of a directory
		and set the sticky bit on it if invoked by non-root (uid != 0) process
		with the following constraints,
		- the process is the owner of the directory.
		- the effective group ID or one of the supplementary group ID's of the
		process is equal to the group ID of the directory.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/chmod/chmod04.c
	<\test_location>
<\testname>
<testname=chmod05>
	<description>
		Verify that, chmod(2) will succeed to change the mode of a directory
		but fails to set the setgid bit on it if invoked by non-root (uid != 0)
		process with the following constraints,
		- the process is the owner of the directory.
		- the effective group ID or one of the supplementary group ID's of the
		process is not equal to the group ID of the directory.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/chmod/chmod05.c
	<\test_location>
<\testname>
<testname=chmod06>
	<description>
		Verify that,
		1) chmod(2) returns -1 and sets errno to EPERM if the effective user id
		of process does not match the owner of the file and the process is
		not super user.
		2) chmod(2) returns -1 and sets errno to EACCES if search permission is
		denied on a component of the path prefix.
		3) chmod(2) returns -1 and sets errno to EFAULT if pathname points
		outside user's accessible address space.
		4) chmod(2) returns -1 and sets errno to ENAMETOOLONG if the pathname
		component is too long.
		5) chmod(2) returns -1 and sets errno to ENOTDIR if the directory
		component in pathname is not a directory.
		6) chmod(2) returns -1 and sets errno to ENOENT if the specified file
		does not exists.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/chmod/chmod06.c
	<\test_location>
<\testname>
<testname=chmod07>
	<description>
		Verify that, chmod(2) will succeed to change the mode of a file/directory
		and sets the sticky bit on it if invoked by root (uid = 0) process with
		the following constraints,
		- the process is not the owner of the file/directory.
		- the effective group ID or one of the supplementary group ID's of the
		process is equal to the group ID of the file/directory.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/chmod/chmod07.c
	<\test_location>
<\testname>
<testname=chown01>
	<description>
		Basic test for chown(2).

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/chown/chown01.c
	<\test_location>
<\testname>
<testname=chown02>
	<description>
		Verify that, when chown(2) invoked by super-user to change the owner and
		group of a file specified by path to any numeric owner(uid)/group(gid)
		values,
		- clears setuid and setgid bits set on an executable file.
		- preserves setgid bit set on a non-group-executable file.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/chown/chown02.c
	<\test_location>
<\testname>
<testname=chown03>
	<description>
		Verify that, chown(2) succeeds to change the group of a file specified
		by path when called by non-root user with the following constraints,
		- euid of the process is equal to the owner of the file.
		- the intended gid is either egid, or one of the supplementary gids
		of the process.
		Also, verify that chown() clears the setuid/setgid bits set on the file.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/chown/chown03.c
	<\test_location>
<\testname>
<testname=chown04>
	<description>
		Verify that,
		1) chown(2) returns -1 and sets errno to EPERM if the effective user id
		of process does not match the owner of the file and the process is
		not super user.
		2) chown(2) returns -1 and sets errno to EACCES if search permission is
		denied on a component of the path prefix.
		3) chown(2) returns -1 and sets errno to EFAULT if pathname points
		outside user's accessible address space.
		4) chown(2) returns -1 and sets errno to ENAMETOOLONG if the pathname
		component is too long.
		5) chown(2) returns -1 and sets errno to ENOTDIR if the directory
		component in pathname is not a directory.
		6) chown(2) returns -1 and sets errno to ENOENT if the specified file
		does not exists.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/chown/chown04.c
	<\test_location>
<\testname>
<testname=chown05>
	<description>
		Verify that, chown(2) succeeds to change the owner and group of a file
		specified by path to any numeric owner(uid)/group(gid) values when invoked
		by super-user.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/chown/chown05.c
	<\test_location>
<\testname>
<testname=chroot01>
	<description>
		Testcase to check the whether chroot sets errno to EPERM.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/chroot/chroot01.c
	<\test_location>
<\testname>
<testname=chroot02>
	<description>
		Test functionality of chroot(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/chroot/chroot02.c
	<\test_location>
<\testname>
<testname=chroot03>
	<description>
		Testcase to test whether chroot(2) sets errno correctly.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/chroot/chroot03.c
	<\test_location>
<\testname>
<testname=clone01>
	<description>
		Basic test for clone(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/clone/clone01.c
	<\test_location>
<\testname>
<testname=clone02>
	<description>
		Functionality tests for clone(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/clone/clone02.c
	<\test_location>
<\testname>
<testname=clone03>
	<description>
		Test for clone(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/clone/clone03.c
	<\test_location>
<\testname>
<testname=clone04>
	<description>
		Test for checking error conditions for clone(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/clone/clone04.c
	<\test_location>
<\testname>
<testname=clone05>
	<description>
		Test for CLONE_VFORK flag

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/clone/clone05.c
	<\test_location>
<\testname>
<testname=clone06>
	<description>
		Test to verify inheritance of environment variables.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/clone/clone06.c
	<\test_location>
<\testname>
<testname=close01>
	<description>
		Test that closing a regular file and a pipe works correctly

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/close/close01.c
	<\test_location>
<\testname>
<testname=close02>
	<description>
		Check that an invalid file descriptor returns EBADF

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/close/close02.c
	<\test_location>
<\testname>
<testname=close08>
	<description>
		Basic test for close(2).

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/close/close08.c
	<\test_location>
<\testname>
<testname=confstr01>
	<description>
		Basic test for confstr().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/confstr/confstr01.c
	<\test_location>
<\testname>
<testname=connect01>
	<description>
		Verify that connect() returns the proper errno for various failure cases

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/connect/connect01.c
	<\test_location>
<\testname>
<testname=creat01>
	<description>
		Testcase to check the basic functionality of the creat(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/creat/creat01.c
	<\test_location>
<\testname>
<testname=creat03>
	<description>
		Testcase to check whether the sticky bit cleared.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/creat/creat03.c
	<\test_location>
<\testname>
<testname=creat04>
	<description>
		Testcase to check creat(2) fails with EACCES

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/creat/creat04.c
	<\test_location>
<\testname>
<testname=creat05>
	<description>
		Testcase to check that creat(2) system call returns EMFILE.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/creat/creat05.c
	<\test_location>
<\testname>
<testname=creat06>
	<description>
		Testcase to check creat(2) sets the following errnos correctly:
		1. EISDIR
		2. ENAMETOOLONG
		3. ENOENT
		4. ENOTDIR
		5. EFAULT
		6. EACCES

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/creat/creat06.c
	<\test_location>
<\testname>
<testname=creat07>
	<description>
		Testcase to check creat(2) sets the following errnos correctly:
		1. ETXTBSY

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/creat/creat07.c
	<\test_location>
<\testname>
<testname=creat08>
	<description>
		Verifies that the group ID and setgid bit are set correctly when
		a new file is created.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/creat/creat08.c
	<\test_location>
<\testname>
<testname=creat09>
	<description>
		Basic test for creat(2) using 0700 argument.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/creat/creat09.c
	<\test_location>
<\testname>
<testname=dup01>
	<description>
		Basic test for dup(2).

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/dup/dup01.c
	<\test_location>
<\testname>
<testname=dup02>
	<description>
		Negative test for dup(2) with bad fd.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/dup/dup02.c
	<\test_location>
<\testname>
<testname=dup03>
	<description>
		Negative test for dup(2) (too many fds).

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/dup/dup03.c
	<\test_location>
<\testname>
<testname=dup04>
	<description>
		Basic test for dup(2) of a system pipe descriptor.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/dup/dup04.c
	<\test_location>
<\testname>
<testname=dup05>
	<description>
		Basic test for dup(2) of a named pipe descriptor.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/dup/dup05.c
	<\test_location>
<\testname>
<testname=dup06>
	<description>
		Test if dup returns -1 on the 21st file when _NFILE is 20.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/dup/dup06.c
	<\test_location>
<\testname>
<testname=dup07>
	<description>
		Test if the access mode is the same for both file descriptors.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/dup/dup07.c
	<\test_location>
<\testname>
<testname=dup201>
	<description>
		Negative tests for dup2() with bad fd (EBADF), and for "too many
		open files" (EMFILE)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/dup2/dup201.c
	<\test_location>
<\testname>
<testname=dup202>
	<description>
		Is the access mode the same for both file descriptors?
		0: read only ? "0444"
		1: write only ? "0222"
		2: read/write ? "0666"

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/dup2/dup202.c
	<\test_location>
<\testname>
<testname=dup203>
	<description>
		Testcase to check the basic functionality of dup2().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/dup2/dup203.c
	<\test_location>
<\testname>
<testname=dup204>
	<description>
		Testcase to check the basic functionality of dup2(2).

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/dup2/dup204.c
	<\test_location>
<\testname>
<testname=dup205>
	<description>
		Testcase to check if -1 is returned on the 21st file when _NFILE is 20.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/dup2/dup205.c
	<\test_location>
<\testname>
<testname=execl01>
	<description>
		Basic test for execl(2).

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/execl/execl01.c
	<\test_location>
<\testname>
<testname=execle01>
	<description>
		Basic test for execle(2).

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/execle/execle01.c
	<\test_location>
<\testname>
<testname=execlp01>
	<description>
		Basic test for execlp(2).

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/execlp/execlp01.c
	<\test_location>
<\testname>
<testname=execv01>
	<description>
		Basic test for execv(2).

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/execv/execv01.c
	<\test_location>
<\testname>
<testname=execve01>
	<description>
		Basic test for execve(2).

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/execve/execve01.c
	<\test_location>
<\testname>
<testname=execve02>
	<description>
		Testcase to check whether execve(2) sets errno to EACCES correctly

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/execve/execve02.c
	<\test_location>
<\testname>
<testname=execve03>
	<description>
		Testcase to check execve sets the following errnos correctly:
		1. ENAMETOOLONG
		2. ENOENT
		3. ENOTDIR
		4. EFAULT
		5. EACCES
		6. ENOEXEC

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/execve/execve03.c
	<\test_location>
<\testname>
<testname=execve04>
	<description>
		Testcase to check execve(2) sets errno to EMFILE correctly

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/execve/execve04.c
	<\test_location>
<\testname>
<testname=execve05>
	<description>
		Testcase to check execve sets the following errnos correctly:
		1. ETXTBSY

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/execve/execve05.c
	<\test_location>
<\testname>
<testname=execvp01>
	<description>
		Basic test for execvp(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/execvp/execvp01.c
	<\test_location>
<\testname>
<testname=exit01>
	<description>
		Check that exit returns the correct values to the waiting parent

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/exit/exit01.c
	<\test_location>
<\testname>
<testname=exit02>
	<description>
		Check that exit flushes output file buffers and closes files upon
		exitting

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/exit/exit02.c
	<\test_location>
<\testname>
<testname=fchdir01>
	<description>
		create a directory and cd into it.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fchdir/fchdir01.c
	<\test_location>
<\testname>
<testname=fchdir02>
	<description>
		try to cd into a bad directory (bad fd).

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fchdir/fchdir02.c
	<\test_location>
<\testname>
<testname=fchmod01>
	<description>
		Basic test for Fchmod(2).

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fchmod/fchmod01.c
	<\test_location>
<\testname>
<testname=fchmod02>
	<description>
		Verify that, fchmod(2) will succeed to change the mode of a file/directory
		set the sticky bit on it if invoked by root (uid = 0) process with
		the following constraints,
		- the process is not the owner of the file/directory.
		- the effective group ID or one of the supplementary group ID's of the
		process is equal to the group ID of the file/directory.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fchmod/fchmod02.c
	<\test_location>
<\testname>
<testname=fchmod03>
	<description>
		Verify that, fchmod(2) will succeed to change the mode of a file
		and set the sticky bit on it if invoked by non-root (uid != 0)
		process with the following constraints,
		- the process is the owner of the file.
		- the effective group ID or one of the supplementary group ID's of the
		process is equal to the group ID of the file.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fchmod/fchmod03.c
	<\test_location>
<\testname>
<testname=fchmod04>
	<description>
		Verify that, fchmod(2) will succeed to change the mode of a directory
		and set the sticky bit on it if invoked by non-root (uid != 0) process
		with the following constraints,
		- the process is the owner of the directory.
		- the effective group ID or one of the supplementary group ID's of the
		process is equal to the group ID of the directory.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fchmod/fchmod04.c
	<\test_location>
<\testname>
<testname=fchmod05>
	<description>
		Verify that, fchmod(2) will succeed to change the mode of a directory
		but fails to set the setgid bit on it if invoked by non-root (uid != 0)
		process with the following constraints,
		- the process is the owner of the directory.
		- the effective group ID or one of the supplementary group ID's of the
		process is not equal to the group ID of the directory.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fchmod/fchmod05.c
	<\test_location>
<\testname>
<testname=fchmod06>
	<description>
		Verify that,
		1) fchmod(2) returns -1 and sets errno to EPERM if the effective user id
		of process does not match the owner of the file and the process is
		not super user.
		2) fchmod(2) returns -1 and sets errno to EBADF if the file descriptor
		of the specified file is not valid.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fchmod/fchmod06.c
	<\test_location>
<\testname>
<testname=fchmod07>
	<description>
		Verify that, fchmod(2) succeeds when used to change the mode permissions
		of a file specified by file descriptor.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fchmod/fchmod07.c
	<\test_location>
<\testname>
<testname=fchown01>
	<description>
		Basic test for fchown(2).

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fchown/fchown01.c
	<\test_location>
<\testname>
<testname=fchown02>
	<description>
		Verify that, when fchown(2) invoked by super-user to change the owner and
		group of a file specified by file descriptor to any numeric
		owner(uid)/group(gid) values,
		- clears setuid and setgid bits set on an executable file.
		- preserves setgid bit set on a non-group-executable file.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fchown/fchown02.c
	<\test_location>
<\testname>
<testname=fchown03>
	<description>
		Verify that, fchown(2) succeeds to change the group of a file specified
		by path when called by non-root user with the following constraints,
		- euid of the process is equal to the owner of the file.
		- the intended gid is either egid, or one of the supplementary gids
		of the process.
		Also, verify that fchown() clears the setuid/setgid bits set on the file.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fchown/fchown03.c
	<\test_location>
<\testname>
<testname=fchown04>
	<description>
		Verify that,
		1) fchown(2) returns -1 and sets errno to EPERM if the effective user id
		of process does not match the owner of the file and the process is
		not super user.
		2) fchown(2) returns -1 and sets errno to EBADF if the file descriptor
		of the specified file is not valid.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fchown/fchown04.c
	<\test_location>
<\testname>
<testname=fchown05>
	<description>
		Verify that, fchown(2) succeeds to change the owner and group of a file
		specified by file descriptor to any numeric owner(uid)/group(gid) values
		when invoked by super-user.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fchown/fchown05.c
	<\test_location>
<\testname>
<testname=fcntl01>
	<description>
		Test F_DUPFD, F_SETFL cmds of fcntl

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fcntl/fcntl01.c
	<\test_location>
<\testname>
<testname=fcntl02>
	<description>
		Basic test for fcntl(2) using F_DUPFD argument.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fcntl/fcntl02.c
	<\test_location>
<\testname>
<testname=fcntl03>
	<description>
		Basic test for fcntl(2) using F_GETFD argument.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fcntl/fcntl03.c
	<\test_location>
<\testname>
<testname=fcntl04>
	<description>
		Basic test for fcntl(2) using F_GETFL argument.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fcntl/fcntl04.c
	<\test_location>
<\testname>
<testname=fcntl05>
	<description>
		Basic test for fcntl(2) using F_GETLK argument.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fcntl/fcntl05.c
	<\test_location>
<\testname>
<testname=fcntl06>
	<description>
		Error checking conditions for remote locking of regions of a file.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fcntl/fcntl06.c
	<\test_location>
<\testname>
<testname=fcntl07>
	<description>
		Close-On-Exec functional test.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fcntl/fcntl07.c
	<\test_location>
<\testname>
<testname=fcntl07B>
	<description>
		Close-On-Exec of named pipe functional test.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fcntl/fcntl07B.c
	<\test_location>
<\testname>
<testname=fcntl08>
	<description>
		Basic test for fcntl(2) using F_SETFL argument.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fcntl/fcntl08.c
	<\test_location>
<\testname>
<testname=fcntl09>
	<description>
		Basic test for fcntl(2) using F_SETLK argument.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fcntl/fcntl09.c
	<\test_location>
<\testname>
<testname=fcntl10>
	<description>
		Basic test for fcntl(2) using F_SETLKW argument.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fcntl/fcntl10.c
	<\test_location>
<\testname>
<testname=fcntl11>
	<description>
		Testcase to check locking of regions of a file

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fcntl/fcntl11.c
	<\test_location>
<\testname>
<testname=fcntl12>
	<description>
		Testcase to test that fcntl() sets EMFILE for F_DUPFD command.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fcntl/fcntl12.c
	<\test_location>
<\testname>
<testname=fcntl13>
	<description>
		Testcase to test that fcntl() sets errno correctly.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fcntl/fcntl13.c
	<\test_location>
<\testname>
<testname=fcntl14>
	<description>
		File locking test cases for fcntl. In Linux, S_ENFMT is not implemented
		in the kernel. However all standard Unix kernels define S_ENFMT as
		S_ISGID. So this test defines S_ENFMT as S_ISGID.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fcntl/fcntl14.c
	<\test_location>
<\testname>
<testname=fcntl15>
	<description>
		Check that file locks are removed when file closed

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fcntl/fcntl15.c
	<\test_location>
<\testname>
<testname=fcntl16>
	<description>
		Additional file locking test cases for checking proper notifictaion
		of processes on lock change

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fcntl/fcntl16.c
	<\test_location>
<\testname>
<testname=fcntl17>
	<description>
		Check deadlock detection for file locking

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fcntl/fcntl17.c
	<\test_location>
<\testname>
<testname=fcntl18>
	<description>
		Test to check the error conditions in fcntl system call

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fcntl/fcntl18.c
	<\test_location>
<\testname>
<testname=fcntl19>
	<description>
		Testcase to check locking of regions of a file

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fcntl/fcntl19.c
	<\test_location>
<\testname>
<testname=fcntl20>
	<description>
		Check locking of regions of a file

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fcntl/fcntl20.c
	<\test_location>
<\testname>
<testname=fcntl21>
	<description>
		Check locking of regions of a file

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fcntl/fcntl21.c
	<\test_location>
<\testname>
<testname=fdatasync01>
	<description>
		Basic test for fdatasync(2).

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fdatasync/fdatasync01.c
	<\test_location>
<\testname>
<testname=fdatasync02>
	<description>
		Checking error conditions for fdatasync(2).

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fdatasync/fdatasync02.c
	<\test_location>
<\testname>
<testname=flock01>
	<description>
		Basic test for flock(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/flock/flock01.c
	<\test_location>
<\testname>
<testname=flock02>
	<description>
		Error condition test for flock(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/flock/flock02.c
	<\test_location>
<\testname>
<testname=flock03>
	<description>
		Error condition test for flock(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/flock/flock03.c
	<\test_location>
<\testname>
<testname=flock04>
	<description>
		Testing different locks on flock(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/flock/flock04.c
	<\test_location>
<\testname>
<testname=flock05>
	<description>
		Testing different locks on flock(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/flock/flock05.c
	<\test_location>
<\testname>
<testname=flock06>
	<description>
		Error condition test for flock(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/flock/flock06.c
	<\test_location>
<\testname>
<testname=fmtmsg01>
	<description>
		Basic test of fmtmsg().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fmtmsg/fmtmsg01.c
	<\test_location>
<\testname>
<testname=fork01>
	<description>
		Basic test for fork(2).

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fork/fork01.c
	<\test_location>
<\testname>
<testname=fork02>
	<description>
		Test correct operation of fork:
		pid == 0 in child;
		pid > 0 in parent from wait;

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fork/fork02.c
	<\test_location>
<\testname>
<testname=fork03>
	<description>
		Check that child can use a large text space and do a large
		number of operations.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fork/fork03.c
	<\test_location>
<\testname>
<testname=fork04>
	<description>
		Child inheritance of Environment Variables after fork().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fork/fork04.c
	<\test_location>
<\testname>
<testname=fork05>
	<description>
		Make sure LDT is propagated correctly

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fork/fork05.c
	<\test_location>
<\testname>
<testname=fork06>
	<description>
		Test that a process can fork children a large number of
		times in succession

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fork/fork06.c
	<\test_location>
<\testname>
<testname=fork07>
	<description>
		Check that all children inherit parent's file descriptor

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fork/fork07.c
	<\test_location>
<\testname>
<testname=fork08>
	<description>
		Check if the parent's file descriptors are affected by
		actions in the child; they should not be.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fork/fork08.c
	<\test_location>
<\testname>
<testname=fork09>
	<description>
		Check that child has access to a full set of files.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fork/fork09.c
	<\test_location>
<\testname>
<testname=fork10>
	<description>
		Check inheritance of file descriptor by children, they
		should all be refering to the same file.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fork/fork10.c
	<\test_location>
<\testname>
<testname=fork11>
	<description>
		Test that parent gets a pid from each child when doing wait

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fork/fork11.c
	<\test_location>
<\testname>
<testname=fork12>
	<description>
		Check that all children inherit parent's file descriptor

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fork/fork12.c
	<\test_location>
<\testname>
<testname=fpathconf>
	<description>
		Basic test for fpathconf(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fpathconf
	<\test_location>
<\testname>
<testname=fstat01>
	<description>
		Basic test for fstat(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fstat/fstat01.c
	<\test_location>
<\testname>
<testname=fstat02>
	<description>
		Verify that, fstat(2) succeeds to get the status of a file and fills
		the stat structure elements though file pointed to by file descriptor
		not opened for reading.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fstat/fstat02.c
	<\test_location>
<\testname>
<testname=fstat03>
	<description>
		Verify that, fstat(2) returns -1 and sets errno to EBADF if the file
		pointed to by file descriptor is not valid.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fstat/fstat03.c
	<\test_location>
<\testname>
<testname=fstat05>
	<description>
		Verify that, if buffer points outside user's accessible address space
		fstat(2) either returns -1 and sets errno to EFAULT or
		SIGSEGV is returned instead of EFAULT.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fstat/fstat05.c
	<\test_location>
<\testname>
<testname=fstatfs01>
	<description>
		Basic test for fstatfs(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fstatfs/fstatfs01.c
	<\test_location>
<\testname>
<testname=fstatfs02>
	<description>
		Testcase to check fstatfs() sets errno correctly.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fstatfs/fstatfs02.c
	<\test_location>
<\testname>
<testname=fsync01>
	<description>
		Basic test for fsync(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fsync/fsync01.c
	<\test_location>
<\testname>
<testname=fsync02>
	<description>
		Create a sparse file, fsync it, and time the fsync

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fsync/fsync02.c
	<\test_location>
<\testname>
<testname=fsync03>
	<description>
		Testcase to check that fsync(2) sets errno correctly.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/fsync/fsync03.c
	<\test_location>
<\testname>
<testname=ftruncate01>
	<description>
		Verify that, ftruncate(2) succeeds to truncate a file to a specified
		length if the file indicated by file descriptor opened for writing.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ftruncate/ftruncate01.c
	<\test_location>
<\testname>
<testname=ftruncate02>
	<description>
		Verify that, ftruncate(2) succeeds to truncate a file to a certain length,
		but the attempt to read past the truncated length will fail.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ftruncate/ftruncate02.c
	<\test_location>
<\testname>
<testname=ftruncate03>
	<description>
		Verify that,
		1) ftruncate(2) returns -1 and sets errno to EINVAL if the specified
		truncate length is less than 0.
		2) ftruncate(2) returns -1 and sets errno to EBADF if the file descriptor
		of the specified file is not valid.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ftruncate/ftruncate03.c
	<\test_location>
<\testname>
<testname=ftruncate04>
	<description>
		Test ftruncate/truncate and mandatory record locking.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ftruncate/ftruncate04.c
	<\test_location>
<\testname>
<testname=getcwd01>
	<description>
		Testcase to test that getcwd(2) sets errno correctly.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getcwd/getcwd01.c
	<\test_location>
<\testname>
<testname=getcwd02>
	<description>
		Testcase to check the basic functionality of the getcwd(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getcwd/getcwd02.c
	<\test_location>
<\testname>
<testname=getcwd03>
	<description>
		Testcase to check the basic functionality of the getcwd(2) system call
		for symbolically linked directories.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getcwd/getcwd03.c
	<\test_location>
<\testname>
<testname=getdents01>
	<description>
		get a directory entry

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getdents/getdents01.c
	<\test_location>
<\testname>
<testname=getdents02>
	<description>
		check that we get a failure with a bad file descriptor

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getdents/getdents02.c
	<\test_location>
<\testname>
<testname=getdents03>
	<description>
		check for an EINVAL error

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getdents/getdents03.c
	<\test_location>
<\testname>
<testname=getdents04>
	<description>
		check for an ENOTDIR error

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getdents/getdents04.c
	<\test_location>
<\testname>
<testname=getdents05>
	<description>
		check that we get a failure with a bad dirp address.

	<\description>
	<test_location>
	<\test_location>
<\testname>
<testname=getdomainname01>
	<description>
		Basic test for getdomainname().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getdomainname/getdomainname01.c
	<\test_location>
<\testname>
<testname=getegid01>
	<description>
		Basic test for getegid(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getegid/getegid01.c
	<\test_location>
<\testname>
<testname=geteuid01>
	<description>
		Basic test for geteuid(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/geteuid/geteuid01.c
	<\test_location>
<\testname>
<testname=getgid01>
	<description>
		Basic test for getgid(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getgid/getgid01.c
	<\test_location>
<\testname>
<testname=getgid02>
	<description>
		Testcase to check the basic functionality of getgid().

	<\description>
	<test_location>
	<\test_location>
<\testname>
<testname=getgid03>
	<description>
		Testcase to check the basic functionality of getegid().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getgid/getgid03.c
	<\test_location>
<\testname>
<testname=getgroups01>
	<description>
		Getgroups system call critical test

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getgroups/getgroups01.c
	<\test_location>
<\testname>
<testname=getgroups02>
	<description>
		Basic test for getgroups(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getgroups/getgroups02.c
	<\test_location>
<\testname>
<testname=getgroups03>
	<description>
		Verify that, getgroups() system call gets the supplementary group IDs
		of the calling process.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getgroups/getgroups03.c
	<\test_location>
<\testname>
<testname=getgroups04>
	<description>
		Verify that,
		getgroups() fails with -1 and sets errno to EINVAL if the size
		argument value is -ve.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getgroups/getgroups04.c
	<\test_location>
<\testname>
<testname=gethostid01>
	<description>
		Basic test for gethostid(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/gethostid/gethostid01.c
	<\test_location>
<\testname>
<testname=gethostname01>
	<description>
		Basic test for gethostname(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/gethostname/gethostname01.c
	<\test_location>
<\testname>
<testname=getitimer01>
	<description>
		Check that a correct call to getitimer() succeeds

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getitimer/getitimer01.c
	<\test_location>
<\testname>
<testname=getitimer02>
	<description>
		Check that a getitimer() call fails as expected
		with an incorrect second argument.
		getitimer03

		Check that a getitimer() call fails as expected
		with an incorrect first argument.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getitimer/getitimer02.c
	<\test_location>
<\testname>
<testname=getpeername01>
	<description>
		Verify that getpeername() returns the proper errno for various failure cases

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getpeername/getpeername01.c
	<\test_location>
<\testname>
<testname=getpgid01>
	<description>
		Testcase to check the basic functionality of getpgid().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getpgid/getpgid01.c
	<\test_location>
<\testname>
<testname=getpgid02>
	<description>
		Testcase to check the basic functionality of getpgid().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getpgid/getpgid02.c
	<\test_location>
<\testname>
<testname=getpgrp01>
	<description>
		Basic test for getpgrp(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getpgrp/getpgrp01.c
	<\test_location>
<\testname>
<testname=getpid01>
	<description>
		Basic test for getpid(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getpid/getpid01.c
	<\test_location>
<\testname>
<testname=getpid02>
	<description>
		Verify that getpid() system call gets the process ID of the of the
		calling process.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getpid/getpid02.c
	<\test_location>
<\testname>
<testname=getppid01>
	<description>
		Testcase to check the basic functionality of the getppid() syscall.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getppid/getppid01.c
	<\test_location>
<\testname>
<testname=getpriority01>
	<description>
		Verify that getpriority() succeeds get the scheduling priority of
		the current process, process group or user.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getpriority/getpriority01.c
	<\test_location>
<\testname>
<testname=getpriority02>
	<description>
		Verify that,
		1) getpriority() sets errno to ESRCH if no process was located
		was located for 'which' and 'who' arguments.
		2) getpriority() sets errno to EINVAL if 'which' argument was
		not one of PRIO_PROCESS, PRIO_PGRP, or PRIO_USER.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getpriority/getpriority02.c
	<\test_location>
<\testname>
<testname=getresgid01>
	<description>
		Verify that getresgid() will be successful to get the real, effective
		and saved user id of the calling process.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getresgid/getresgid01.c
	<\test_location>
<\testname>
<testname=getresgid02>
	<description>
		Verify that getresgid() will be successful to get the real, effective
		and saved user ids after calling process invokes setregid() to change
		the effective/saved gids to that of specified user.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getresgid/getresgid02.c
	<\test_location>
<\testname>
<testname=getresgid03>
	<description>
		Verify that getresgid() will be successful to get the real, effective
		and saved user ids after calling process invokes setresgid() to change
		the effective gid to that of specified user.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getresgid/getresgid03.c
	<\test_location>
<\testname>
<testname=getresuid01>
	<description>
		Verify that getresuid() will be successful to get the real, effective
		and saved user id of the calling process.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getresuid/getresuid01.c
	<\test_location>
<\testname>
<testname=getresuid02>
	<description>
		Verify that getresuid() will be successful to get the real, effective
		and saved user ids after calling process invokes setreuid() to change
		the effective/saved uids to that of specified user.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getresuid/getresuid02.c
	<\test_location>
<\testname>
<testname=getresuid03>
	<description>
		Verify that getresuid() will be successful to get the real, effective
		and saved user ids after calling process invokes setresuid() to change
		the effective uid to that of specified user.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getresuid/getresuid03.c
	<\test_location>
<\testname>
<testname=getsid01>
	<description>
		call getsid() and make sure it succeeds

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getsid/getsid01.c
	<\test_location>
<\testname>
<testname=getsid02>
	<description>
		call getsid() with an invalid PID to produce a failure

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getsid/getsid02.c
	<\test_location>
<\testname>
<testname=getsockname01>
	<description>
		Verify that getsockname() returns the proper errno for various failure cases

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getsockname/getsockname01.c
	<\test_location>
<\testname>
<testname=getsockopt01>
	<description>
		Verify that getsockopt() returns the proper errno for various failure cases

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getsockopt/getsockopt01.c
	<\test_location>
<\testname>
<testname=gettimeofday01>
	<description>
		Testcase to check that gettimeofday(2) sets errno to EFAULT.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/gettimeofday/gettimeofday01.c
	<\test_location>
<\testname>
<testname=gettimeofday02>
	<description>
		Testcase to check if gettimeofday is monotonous.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/gettimeofday/gettimeofday02.c
	<\test_location>
<\testname>
<testname=getuid01>
	<description>
		Basic test for getuid(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getuid/getuid01.c
	<\test_location>
<\testname>
<testname=getuid02>
	<description>
		Testcase to check the basic functionality of the geteuid() system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getuid/getuid02.c
	<\test_location>
<\testname>
<testname=getuid03>
	<description>
		Testcase to check the basic functionality of the getuid() system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/getuid/getuid03.c
	<\test_location>
<\testname>
<testname=ioctl01>
	<description>
		Testcase to check the errnos set by the ioctl(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ioctl/ioctl01.c
	<\test_location>
<\testname>
<testname=ioctl02>
	<description>
		Testcase to test the TCGETA, and TCSETA ioctl implementations for
		the tty driver

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ioctl/ioctl02.c
	<\test_location>
<\testname>
<testname=ioperm01>
	<description>
		Basic test for ioperm().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ioperm/ioperm01.c
	<\test_location>
<\testname>
<testname=ioperm02>
	<description>
		Test for error conditions.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ioperm/ioperm02.c
	<\test_location>
<\testname>
<testname=iopl01>
	<description>
		Basic test for iopl().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/iopl/iopl01.c
	<\test_location>
<\testname>
<testname=iopl02>
	<description>
		Test for error conditions.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/iopl/iopl02.c
	<\test_location>
<\testname>
<testname=msgctl01>
	<description>
		create a message queue, then issue the IPC_STAT command
		and RMID commands to test the functionality

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/msgctl/msgctl01.c
	<\test_location>
<\testname>
<testname=msgctl02>
	<description>
		create a message queue, then issue the IPC_SET command
		to lower the msg_qbytes value.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/msgctl/msgctl02.c
	<\test_location>
<\testname>
<testname=msgctl03>
	<description>
		create a message queue, then issue the IPC_RMID command

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/msgctl/msgctl03.c
	<\test_location>
<\testname>
<testname=msgctl04>
	<description>
		test for EACCES, EFAULT and EINVAL errors using
		a variety of incorrect calls.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/msgctl/msgctl04.c
	<\test_location>
<\testname>
<testname=msgctl05>
	<description>
		test for EPERM error

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/msgctl/msgctl05.c
	<\test_location>
<\testname>
<testname=msgget01>
	<description>
		create a message queue, write a message to it and
		read it back.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/msgget/msgget01.c
	<\test_location>
<\testname>
<testname=msgget02>
	<description>
		test for EEXIST and ENOENT errors

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/msgget/msgget02.c
	<\test_location>
<\testname>
<testname=msgget03>
	<description>
		test for an ENOSPC error by using up all available
		message queues.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/msgget/msgget03.c
	<\test_location>
<\testname>
<testname=msgget04>
	<description>
		test for an EACCES error by creating a message queue
		with no read or write permission and then attempting
		to access it with various permissions.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/msgget/msgget04.c
	<\test_location>
<\testname>
<testname=msgrcv01>
	<description>
		test that msgrcv() receives the expected message

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/msgrcv/msgrcv01.c
	<\test_location>
<\testname>
<testname=msgrcv02>
	<description>
		test for EACCES and EFAULT errors

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/msgrcv/msgrcv02.c
	<\test_location>
<\testname>
<testname=msgrcv03>
	<description>
		test for EINVAL error

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/msgrcv/msgrcv03.c
	<\test_location>
<\testname>
<testname=msgrcv04>
	<description>
		test for E2BIG and ENOMSG errors

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/msgrcv/msgrcv04.c
	<\test_location>
<\testname>
<testname=msgrcv05>
	<description>
		test for EINTR error

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/msgrcv/msgrcv05.c
	<\test_location>
<\testname>
<testname=msgrcv06>
	<description>
		test for EIDRM error

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/msgrcv/msgrcv06.c
	<\test_location>
<\testname>
<testname=msgsnd01>
	<description>
		test that msgsnd() enqueues a message correctly

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/msgsnd/msgsnd01.c
	<\test_location>
<\testname>
<testname=msgsnd02>
	<description>
		test for EACCES and EFAULT errors

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/msgsnd/msgsnd02.c
	<\test_location>
<\testname>
<testname=msgsnd03>
	<description>
		test for EINVAL error

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/msgsnd/msgsnd03.c
	<\test_location>
<\testname>
<testname=msgsnd04>
	<description>
		test for EAGAIN error

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/msgsnd/msgsnd04.c
	<\test_location>
<\testname>
<testname=msgsnd05>
	<description>
		test for EINTR error

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/msgsnd/msgsnd05.c
	<\test_location>
<\testname>
<testname=msgsnd06>
	<description>
		test for EIDRM error

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/msgsnd/msgsnd06.c
	<\test_location>
<\testname>
<testname=semctl01>
	<description>
		test the 10 possible semctl() commands

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/semctl/semctl01.c
	<\test_location>
<\testname>
<testname=semctl02>
	<description>
		test for EACCES error

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/semctl/semctl02.c
	<\test_location>
<\testname>
<testname=semctl03>
	<description>
		test for EINVAL and EFAULT errors

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/semctl/semctl03.c
	<\test_location>
<\testname>
<testname=semctl04>
	<description>
		test for EPERM error

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/semctl/semctl04.c
	<\test_location>
<\testname>
<testname=semctl05>
	<description>
		test for ERANGE error

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/semctl/semctl05.c
	<\test_location>
<\testname>
<testname=semget01>
	<description>
		test that semget() correclty creates a semaphore set

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/semget/semget01.c
	<\test_location>
<\testname>
<testname=semget02>
	<description>
		test for EACCES and EEXIST errors

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/semget/semget02.c
	<\test_location>
<\testname>
<testname=semget03>
	<description>
		test for ENOENT error

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/semget/semget03.c
	<\test_location>
<\testname>
<testname=semget05>
	<description>
		test for ENOSPC error

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/semget/semget05.c
	<\test_location>
<\testname>
<testname=semget06>
	<description>
		test for EINVAL error

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/semget/semget06.c
	<\test_location>
<\testname>
<testname=semop01>
	<description>
		test that semop() basic functionality is correct

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/semop/semop01.c
	<\test_location>
<\testname>
<testname=semop02>
	<description>
		test for E2BIG, EACCES, EFAULT and EINVAL errors

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/semop/semop02.c
	<\test_location>
<\testname>
<testname=semop03>
	<description>
		test for EFBIG error

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/semop/semop03.c
	<\test_location>
<\testname>
<testname=semop04>
	<description>
		test for EAGAIN error

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/semop/semop04.c
	<\test_location>
<\testname>
<testname=semop05>
	<description>
		test for EINTR and EIDRM errors

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/semop/semop05.c
	<\test_location>
<\testname>
<testname=shmat01>
	<description>
		test that shmat() works correctly

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/shmat/shmat01.c
	<\test_location>
<\testname>
<testname=shmat02>
	<description>
		check for EINVAL and EACCES errors

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/shmat/shmat02.c
	<\test_location>
<\testname>
<testname=shmat03>
	<description>
		test for EACCES error

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/shmat/shmat03.c
	<\test_location>
<\testname>
<testname=shmctl01>
	<description>
		test the IPC_STAT, IPC_SET and IPC_RMID commands as
		they are used with shmctl()

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/shmctl/shmctl01.c
	<\test_location>
<\testname>
<testname=shmctl02>
	<description>
		check for EACCES, EFAULT and EINVAL errors

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/shmctl/shmctl02.c
	<\test_location>
<\testname>
<testname=shmctl03>
	<description>
		check for EACCES, and EPERM errors

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/shmctl/shmctl03.c
	<\test_location>
<\testname>
<testname=shmdt01>
	<description>
		check that shared memory is detached correctly

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/shmdt/shmdt01.c
	<\test_location>
<\testname>
<testname=shmdt02>
	<description>
		check for EINVAL error

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/shmdt/shmdt02.c
	<\test_location>
<\testname>
<testname=shmget01>
	<description>
		test that shmget() correctly creates a shared memory segment

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/shmget/shmget01.c
	<\test_location>
<\testname>
<testname=shmget02>
	<description>
		check for ENOENT, EEXIST and EINVAL errors

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/shmget/shmget02.c
	<\test_location>
<\testname>
<testname=shmget03>
	<description>
		test for ENOSPC error

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/shmget/shmget03.c
	<\test_location>
<\testname>
<testname=shmget04>
	<description>
		test for EACCES error

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/shmget/shmget04.c
	<\test_location>
<\testname>
<testname=shmget05>
	<description>
		test for EACCES error

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ipc/shmget/shmget05.c
	<\test_location>
<\testname>
<testname=kill01>
	<description>
		Test case to check the basic functionality of kill().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/kill/kill01.c
	<\test_location>
<\testname>
<testname=kill02>
	<description>
		Sending a signal to processes with the same process group ID

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/kill/kill02.c
	<\test_location>
<\testname>
<testname=kill03>
	<description>
		Test case to check that kill fails when given an invalid signal.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/kill/kill03.c
	<\test_location>
<\testname>
<testname=kill04>
	<description>
		Test case to check that kill() fails when passed a non-existant pid.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/kill/kill04.c
	<\test_location>
<\testname>
<testname=kill05>
	<description>
		Test case to check that kill() fails when passed a pid owned by another
		user.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/kill/kill05.c
	<\test_location>
<\testname>
<testname=kill06>
	<description>
		Test case to check the basic functionality of kill() when killing an
		entire process group with a negative pid.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/kill/kill06.c
	<\test_location>
<\testname>
<testname=kill07>
	<description>
		Test case to check that SIGKILL can not be caught.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/kill/kill07.c
	<\test_location>
<\testname>
<testname=kill08>
	<description>
		Test case to check the basic functionality of kill() when kill an
		entire process group.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/kill/kill08.c
	<\test_location>
<\testname>
<testname=kill09>
	<description>
		Basic test for kill(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/kill/kill09.c
	<\test_location>
<\testname>
<testname=kill10>
	<description>
		Signal flooding test.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/kill/kill10.c
	<\test_location>
<\testname>
<testname=kill11>
	<description>
		Check that when a child is killed by its parent, it returns the
		correct values to the waiting parent--child has default values.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/kill/kill11.c
	<\test_location>
<\testname>
<testname=kill12>
	<description>
		Check that when a child is killed by its parent, it returns the
		correct values to the waiting parent--the child sets signal to
		ignore the kill.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/kill/kill12.c
	<\test_location>
<\testname>
<testname=lchown01>
	<description>
		Verify that, lchown(2) succeeds to change the owner and group of a file
		specified by path to any numeric owner(uid)/group(gid) values when invoked
		by super-user.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/lchown/lchown01.c
	<\test_location>
<\testname>
<testname=lchown02>
	<description>
		Verify that,
		1) lchown(2) returns -1 and sets errno to EPERM if the effective user id
		of process does not match the owner of the file and the process is
		not super user.
		2) lchown(2) returns -1 and sets errno to EACCES if search permission is
		denied on a component of the path prefix.
		3) lchown(2) returns -1 and sets errno to EFAULT if pathname points
		outside user's accessible address space.
		4) lchown(2) returns -1 and sets errno to ENAMETOOLONG if the pathname
		component is too long.
		5) lchown(2) returns -1 and sets errno to ENOTDIR if the directory
		component in pathname is not a directory.
		6) lchown(2) returns -1 and sets errno to ENOENT if the specified file
		does not exists.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/lchown/lchown02.c
	<\test_location>
<\testname>
<testname=link02>
	<description>
		Basic test for link(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/link/link02.c
	<\test_location>
<\testname>
<testname=link03>
	<description>
		Multi links tests

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/link/link03.c
	<\test_location>
<\testname>
<testname=link04>
	<description>
		Negative test cases for link(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/link/link04.c
	<\test_location>
<\testname>
<testname=link05>
	<description>
		Multi links (EMLINK) negative test

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/link/link05.c
	<\test_location>
<\testname>
<testname=listen01>
	<description>
		Verify that listen() returns the proper errno for various failure cases

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/listen/listen01.c
	<\test_location>
<\testname>
<testname=llseek01>
	<description>
		Verify that, llseek() call succeeds to set the file pointer position
		to an offset larger than file size. Also, verify that any attempt
		to write to this location fails.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/llseek/llseek01.c
	<\test_location>
<\testname>
<testname=llseek02>
	<description>
		Verify that,
		1. llseek() returns -1 and sets errno to EINVAL, if the 'Whence' argument
		is not a proper value.
		2. llseek() returns -1 and sets errno to EBADF, if the file handle of
		the specified file is not valid.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/llseek/llseek02.c
	<\test_location>
<\testname>
<testname=lseek01>
	<description>
		Basic test for lseek(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/lseek/lseek01.c
	<\test_location>
<\testname>
<testname=lseek02>
	<description>
		Negative test for lseek(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/lseek/lseek02.c
	<\test_location>
<\testname>
<testname=lseek03>
	<description>
		Negative test for lseek(2) whence

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/lseek/lseek03.c
	<\test_location>
<\testname>
<testname=lseek04>
	<description>
		Negative test for lseek(2) of a fifo

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/lseek/lseek04.c
	<\test_location>
<\testname>
<testname=lseek05>
	<description>
		Negative test for lseek(2) of a pipe

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/lseek/lseek05.c
	<\test_location>
<\testname>
<testname=lseek06>
	<description>
		Verify that, lseek() call succeeds to set the file pointer position
		to less than or equal to the file size, when a file is opened for
		read or write.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/lseek/lseek06.c
	<\test_location>
<\testname>
<testname=lseek07>
	<description>
		Verify that, lseek() call succeeds to set the file pointer position
		to more than the file size, when a file is opened for reading/writing.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/lseek/lseek07.c
	<\test_location>
<\testname>
<testname=lseek08>
	<description>
		Verify that, lseek() call succeeds to set the file pointer position
		to the end of the file when 'whence' value set to SEEK_END and any
		attempts to read from that position should fail.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/lseek/lseek08.c
	<\test_location>
<\testname>
<testname=lseek09>
	<description>
		Verify that, lseek() call succeeds to set the file pointer position
		to the current specified location, when 'whence' value is set to
		SEEK_CUR and the data read from the specified location should match
		the expected data.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/lseek/lseek09.c
	<\test_location>
<\testname>
<testname=lseek10>
	<description>
		Verify that,
		1. lseek() returns -1 and sets errno to ESPIPE, if the file handle of
		the specified file is associated with a pipe, socket, or FIFO.
		2. lseek() returns -1 and sets errno to EINVAL, if the 'Whence' argument
		is not a proper value.
		3. lseek() returns -1 and sets errno to EBADF, if the file handle of
		the specified file is not valid.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/lseek/lseek10.c
	<\test_location>
<\testname>
<testname=lstat01>
	<description>
		Verify that, lstat(2) succeeds to get the status of a file pointed to by
		symlink and fills the stat structure elements.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/lstat/lstat01.c
	<\test_location>
<\testname>
<testname=lstat02>
	<description>
		Basic test for lstat(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/lstat/lstat02.c
	<\test_location>
<\testname>
<testname=lstat03>
	<description>
		Verify that,
		1) lstat(2) returns -1 and sets errno to EACCES if search permission is
		denied on a component of the path prefix.
		2) lstat(2) returns -1 and sets errno to ENOENT if the specified file
		does not exists or empty string.
		3) lstat(2) returns -1 and sets errno to EFAULT if pathname points
		outside user's accessible address space.
		4) lstat(2) returns -1 and sets errno to ENAMETOOLONG if the pathname
		component is too long.
		5) lstat(2) returns -1 and sets errno to ENOTDIR if the directory
		component in pathname is not a directory.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/lstat/lstat03.c
	<\test_location>
<\testname>
<testname=mallopt>
	<description>
		Test basic functionality of mallopt().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mallopt
	<\test_location>
<\testname>
<testname=memcmp>
	<description>
		Test basic functionality of memcmp().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/memcmp
	<\test_location>
<\testname>
<testname=memcpy>
	<description>
		Test basic functionality of memcpy().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/memcpy
	<\test_location>
<\testname>
<testname=memset>
	<description>
		Test basic functionality of memset().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/memset
	<\test_location>
<\testname>
<testname=mkdir01>
	<description>
		Basic errno test for mkdir(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mkdir/mkdir01.c
	<\test_location>
<\testname>
<testname=mkdir02>
	<description>
		This test will verify that new directory created
		by mkdir(2) inherites the group ID from the parent
		directory and S_ISGID bit, if the S_ISGID bit is set
		in the parent directory.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mkdir/mkdir02.c
	<\test_location>
<\testname>
<testname=mkdir03>
	<description>
		Check mkdir() with various error conditions that should produce
		EFAULT, ENAMETOOLONG, EEXIST, ENOENT and ENOTDIR

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mkdir/mkdir03.c
	<\test_location>
<\testname>
<testname=mkdir04>
	<description>
		Attempt to create a directory in a directory having no permissions.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mkdir/mkdir04.c
	<\test_location>
<\testname>
<testname=mkdir05>
	<description>
		This test will verify the mkdir(2) syscall basic functionality

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mkdir/mkdir05.c
	<\test_location>
<\testname>
<testname=mkdir08>
	<description>
		Basic test for mkdir(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mkdir/mkdir08.c
	<\test_location>
<\testname>
<testname=mknod01>
	<description>
		Basic test for mknod(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mknod/mknod01.c
	<\test_location>
<\testname>
<testname=mknod02>
	<description>
		Verify that mknod(2) succeeds when used to create a filesystem
		node with set group-ID bit set on a directory without set group-ID bit set.
		The node created should have set group-ID bit set and its gid should be
		equal to that of its parent directory.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mknod/mknod02.c
	<\test_location>
<\testname>
<testname=mknod03>
	<description>
		Verify that mknod(2) succeeds when used to create a filesystem
		node with set group-ID bit set on a directory with set group-ID bit set.
		The node created should have set group-ID bit set and its gid should be
		equal to the effective gid of the process.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mknod/mknod03.c
	<\test_location>
<\testname>
<testname=mknod04>
	<description>
		Verify that mknod(2) succeeds when used to create a filesystem
		node on a directory with set group-ID bit set.
		The node created should not have group-ID bit set and its gid should be
		equal to the effective gid of the process.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mknod/mknod04.c
	<\test_location>
<\testname>
<testname=mknod05>
	<description>
		Verify that mknod(2) succeeds when used by root to create a filesystem
		node with set group-ID bit set on a directory with set group-ID bit set.
		The node created should have set group-ID bit set and its gid should be
		equal to that of its parent directory.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mknod/mknod05.c
	<\test_location>
<\testname>
<testname=mknod06>
	<description>
		Verify that,
		1) mknod(2) returns -1 and sets errno to EEXIST if specified path
		already exists.
		2) mknod(2) returns -1 and sets errno to EFAULT if pathname points
		outside user's accessible address space.
		3) mknod(2) returns -1 and sets errno to ENOENT if the directory
		component in pathname does not exist.
		4) mknod(2) returns -1 and sets errno to ENAMETOOLONG if the pathname
		component was too long.
		5) mknod(2) returns -1 and sets errno to ENOTDIR if the directory
		component in pathname is not a directory.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mknod/mknod06.c
	<\test_location>
<\testname>
<testname=mknod07>
	<description>
		Verify that,
		1) mknod(2) returns -1 and sets errno to EPERM if the process id of
		the caller is not super-user.
		2) mknod(2) returns -1 and sets errno to EACCES if parent directory
		does not allow write permission to the process.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mknod/mknod07.c
	<\test_location>
<\testname>
<testname=mknod08>
	<description>
		Verify that mknod(2) succeeds when used to create a filesystem
		node on a directory without set group-ID bit set. The node created
		should not have set group-ID bit set and its gid should be equal to that
		of its parent directory.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mknod/mknod08.c
	<\test_location>
<\testname>
<testname=mlock01>
	<description>
		Test basic functionality of mlock().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mlock/mlock01.c
	<\test_location>
<\testname>
<testname=mlock02>
	<description>
		Test to see the proper errors are returned by mlock().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mlock/mlock02.c
	<\test_location>
<\testname>
<testname=mlockall01>
	<description>
		Test basic functionality of mlockall().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mlockall/mlockall01.c
	<\test_location>
<\testname>
<testname=mlockall02>
	<description>
		Test to see the proper errors are returned by mlockall().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mlockall/mlockall02.c
	<\test_location>
<\testname>
<testname=mmap001>
	<description>
		Tests mmapping a big file and writing it once

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mmap/mmap001.c
	<\test_location>
<\testname>
<testname=mmap01>
	<description>
		Verify that, mmap() succeeds when used to map a file where size of the
		file is not a multiple of the page size, the memory area beyond the end
		of the file to the end of the page is accessible. Also, verify that
		this area is all zeroed and the modifications done to this area are
		not written to the file.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mmap/mmap01.c
	<\test_location>
<\testname>
<testname=mmap02>
	<description>
		Call mmap() with prot parameter set to PROT_READ and with the file
		descriptor being open for read, to map a file creating mapped memory
		with read access. The minimum file permissions should be 0444.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mmap/mmap02.c
	<\test_location>
<\testname>
<testname=mmap03>
	<description>
		Call mmap() to map a file creating a mapped region with execute access
		under the following conditions -
		- The prot parameter is set to PROT_EXE
		- The file descriptor is open for read
		- The file being mapped has execute permission bit set.
		- The minimum file permissions should be 0555.

		The call should succeed to map the file creating mapped memory with the
		required attributes.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mmap/mmap03.c
	<\test_location>
<\testname>
<testname=mmap04>
	<description>
		Call mmap() to map a file creating a mapped region with read/exec access
		under the following conditions -
		- The prot parameter is set to PROT_READ|PROT_EXEC
		- The file descriptor is open for read
		- The file being mapped has read and execute permission bit set.
		- The minimum file permissions should be 0555.

		The call should succeed to map the file creating mapped memory with the
		required attributes.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mmap/mmap04.c
	<\test_location>
<\testname>
<testname=mmap05>
	<description>
		Call mmap() to map a file creating mapped memory with no access under
		the following conditions -
		- The prot parameter is set to PROT_NONE
		- The file descriptor is open for read(any mode other than write)
		- The minimum file permissions should be 0444.

		The call should succeed to map the file creating mapped memory with the
		required attributes.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mmap/mmap05.c
	<\test_location>
<\testname>
<testname=mmap06>
	<description>
		Call mmap() to map a file creating a mapped region with read access
		under the following conditions -
		- The prot parameter is set to PROT_READ
		- The file descriptor is open for writing.

		The call should fail to map the file.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mmap/mmap06.c
	<\test_location>
<\testname>
<testname=mmap07>
	<description>
		Call mmap() to map a file creating a mapped region with read access
		under the following conditions -
		- The prot parameter is set to PROT_WRITE
		- The file descriptor is open for writing.
		- The flags parameter has MAP_PRIVATE set.

		The call should fail to map the file.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mmap/mmap07.c
	<\test_location>
<\testname>
<testname=mmap08>
	<description>
		Verify that mmap() fails to map a file creating a mapped region
		when the file specified by file descriptor is not valid.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mmap/mmap08.c
	<\test_location>
<\testname>
<testname=mmap09>
	<description>
		Verify that truncating a mmaped file works correctly.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mmap/mmap09.c
	<\test_location>
<\testname>
<testname=modify_ldt01>
	<description>
		Testcase to check the error conditions for modify_ldt(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/modify_ldt/modify_ldt01.c
	<\test_location>
<\testname>
<testname=modify_ldt02>
	<description>
		Testcase to check the error conditions for modify_ldt(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/modify_ldt/modify_ldt02.c
	<\test_location>
<\testname>
<testname=mount01>
	<description>
		Basic test for mount(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mount/mount01.c
	<\test_location>
<\testname>
<testname=mount02>
	<description>
		Test for checking basic error conditions for mount(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mount/mount02.c
	<\test_location>
<\testname>
<testname=mount03>
	<description>
		Test for checking mount(2) flags

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mount/mount03.c
	<\test_location>
<\testname>
<testname=mount04>
	<description>
		Test for checking EPERM

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mount/mount04.c
	<\test_location>
<\testname>
<testname=mprotect01>
	<description>
		Testcase to check the error conditions for mprotect(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mprotect/mprotect01.c
	<\test_location>
<\testname>
<testname=mprotect02>
	<description>
		Testcase to check the mprotect(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mprotect/mprotect02.c
	<\test_location>
<\testname>
<testname=mprotect03>
	<description>
		Testcase to check the mprotect(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mprotect/mprotect03.c
	<\test_location>
<\testname>
<testname=mremap01>
	<description>
		Verify that, mremap() succeeds when used to expand the existing
		virtual memory mapped region to the requested size where the
		virtual memory area was previously mapped to a file using mmap().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mremap/mremap01.c
	<\test_location>
<\testname>
<testname=mremap02>
	<description>
		Verify that,
		mremap() fails when used to expand the existing virtual memory mapped
		region to the requested size, if the virtual memory area previously
		mapped was not page aligned or invalid argument specified.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mremap/mremap02.c
	<\test_location>
<\testname>
<testname=mremap03>
	<description>
		Verify that,
		mremap() fails when used to expand the existing virtual memory mapped
		region to the requested size, if there already exists mappings that
		cover the whole address space requsted or the old address specified was
		not mapped.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mremap/mremap03.c
	<\test_location>
<\testname>
<testname=mremap04>
	<description>
		Verify that,
		mremap() fails when used to expand the existing virtual memory mapped
		region to the requested size, if the memory area cannot be expanded at
		the current virtual address and MREMAP_MAYMOVE flag not set.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/mremap/mremap04.c
	<\test_location>
<\testname>
<testname=msync01>
	<description>
		Verify that, msync() succeeds, when the region to synchronize, is part
		of, or all of a mapped region.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/msync/msync01.c
	<\test_location>
<\testname>
<testname=msync02>
	<description>
		Verify that msync() succeeds when the region to synchronize is mapped
		shared and the flags argument is MS_INVALIDATE.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/msync/msync02.c
	<\test_location>
<\testname>
<testname=msync03>
	<description>
		Verify that, msync() fails, when the region to synchronize, is outside
		the address space of the process.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/msync/msync03.c
	<\test_location>
<\testname>
<testname=msync04>
	<description>
		Verify that, msync() fails, when the region to synchronize, is mapped
		but the flags argument is invalid.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/msync/msync04.c
	<\test_location>
<\testname>
<testname=msync05>
	<description>
		Verify that, msync() fails, when the region to synchronize, was not
		mapped.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/msync/msync05.c
	<\test_location>
<\testname>
<testname=munmap01>
	<description>
		Verify that, munmap call will succeed to unmap a mapped file or
		anonymous shared memory region from the calling process's address space
		and after successful completion of munmap, the unmapped region is no
		longer accessible.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/munmap/munmap01.c
	<\test_location>
<\testname>
<testname=munmap02>
	<description>
		Verify that, munmap call will succeed to unmap a mapped file or
		anonymous shared memory region from the calling process's address space
		if the region specified by the address and the length is part or all of
		the mapped region.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/munmap/munmap02.c
	<\test_location>
<\testname>
<testname=munmap03>
	<description>
		Verify that, munmap call will fail to unmap a mapped file or anonymous
		shared memory region from the calling process's address space if the
		address and the length of the region to be unmapped points outside the
		calling process's address space

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/munmap/munmap03.c
	<\test_location>
<\testname>
<testname=nanosleep01>
	<description>
		Verify that nanosleep() will be successful to suspend the execution
		of a process for a specified time.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/nanosleep/nanosleep01.c
	<\test_location>
<\testname>
<testname=nanosleep02>
	<description>
		Verify that nanosleep() will be successful to suspend the execution
		of a process, returns after the receipt of a signal and writes the
		remaining sleep time into the structure.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/nanosleep/nanosleep02.c
	<\test_location>
<\testname>
<testname=nanosleep03>
	<description>
		Verify that nanosleep() will fail to suspend the execution
		of a process for a specified time if interrupted by a non-blocked signal.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/nanosleep/nanosleep03.c
	<\test_location>
<\testname>
<testname=nanosleep04>
	<description>
		Verify that nanosleep() will fail to suspend the execution
		of a process if the specified pause time is invalid.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/nanosleep/nanosleep04.c
	<\test_location>
<\testname>
<testname=nftw>
	<description>
		Basic test of nftw().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/nftw/nftw.c
	<\test_location>
<\testname>
<testname=nftw64>
	<description>
		Basic test of nftw64()

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/nftw/nftw64.c
	<\test_location>
<\testname>
<testname=nice01>
	<description>
		Verify that root can provide a negative value to nice()
		and hence root can decrease the nice value of the process
		using nice() system call

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/nice/nice01.c
	<\test_location>
<\testname>
<testname=nice02>
	<description>
		Verify that any user can successfully increase the nice value of
		the process by passing a higher increment value (> max. applicable limits)
		to nice() system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/nice/nice02.c
	<\test_location>
<\testname>
<testname=nice03>
	<description>
		Verify that any user can successfully increase the nice value of
		the process by passing an increment value (< max. applicable limits) to
		nice() system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/nice/nice03.c
	<\test_location>
<\testname>
<testname=nice04>
	<description>
		Verify that, nice(2) fails when, a non-root user attempts to increase
		the priority of a process by specifying a negative increment value.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/nice/nice04.c
	<\test_location>
<\testname>
<testname=nice05>
	<description>
		Basic test for nice(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/nice/nice05.c
	<\test_location>
<\testname>
<testname=open01>
	<description>
		Open a file with oflag = O_CREAT set, does it set the sticky bit off?

		Open "/tmp" with O_DIRECTORY, does it set the S_IFDIR bit on?

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/open/open01.c
	<\test_location>
<\testname>
<testname=open02>
	<description>
		Test if open without O_CREAT returns -1 if a file does not exist.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/open/open02.c
	<\test_location>
<\testname>
<testname=open03>
	<description>
		Basic test for open(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/open/open03.c
	<\test_location>
<\testname>
<testname=open04>
	<description>
		Testcase to check that open(2) sets EMFILE if a process opens files
		more than its descriptor size

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/open/open04.c
	<\test_location>
<\testname>
<testname=open05>
	<description>
		Testcase to check open(2) sets errno to EACCES correctly.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/open/open05.c
	<\test_location>
<\testname>
<testname=open06>
	<description>
		Testcase to check open(2) sets errno to ENXIO correctly.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/open/open06.c
	<\test_location>
<\testname>
<testname=open07>
	<description>
		Test the open(2) system call to ensure that it sets ELOOP correctly.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/open/open07.c
	<\test_location>
<\testname>
<testname=open08>
	<description>
		Check for the following errors:
		1. EEXIST
		2. EISDIR
		3. ENOTDIR
		4. ENAMETOOLONG
		5. EFAULT
		6. ETXTBSY

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/open/open08.c
	<\test_location>
<\testname>
<testname=open09>
	<description>
		Does a read on a file opened with oflag set to O_WRONLY and checks for -1 return.
		Does a write on a file opened with oflag set to O_RDONLY and checks for -1 return.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/open/open09.c
	<\test_location>
<\testname>
<testname=open10>
	<description>
		Verifies that the group ID and setgid bit are set correctly when a new file
		is created using open.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/open/open10.c
	<\test_location>
<\testname>
<testname=pathconf01>
	<description>
		Basic test for pathconf(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/pathconf/pathconf01.c
	<\test_location>
<\testname>
<testname=pause01>
	<description>
		Basic test for pause(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/pause/pause01.c
	<\test_location>
<\testname>
<testname=pause02>
	<description>
		Verify that, pause() returns -1 and sets errno to EINTR after receipt
		of a signal which is caught by the calling process. Also, verify that
		the calling process will resume execution from the point of suspension.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/pause/pause02.c
	<\test_location>
<\testname>
<testname=pause03>
	<description>
		Verify that a process is no longer accessible on receipt of SIGKILL
		signal after being suspended by pause().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/pause/pause03.c
	<\test_location>
<\testname>
<testname=personality01>
	<description>
		Check that we can set the personality for a process.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/personality/personality01.c
	<\test_location>
<\testname>
<testname=personality02>
	<description>
		Check that we get EINVAL for a bad personality.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/personality/personality02.c
	<\test_location>
<\testname>
<testname=pipe01>
	<description>
		Testcase to check the basic functionality of the pipe(2) syscall:
		Check that both ends of the pipe (both file descriptors) are
		available to a process opening the pipe.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/pipe/pipe01.c
	<\test_location>
<\testname>
<testname=pipe05>
	<description>
		Check what happens when pipe is passed a bad file descriptor.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/pipe/pipe05.c
	<\test_location>
<\testname>
<testname=pipe06>
	<description>
		Check what happens when the system runs out of pipes.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/pipe/pipe06.c
	<\test_location>
<\testname>
<testname=pipe08>
	<description>
		Check that a SIGPIPE signal is generated when a write is
		attempted on an empty pipe.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/pipe/pipe08.c
	<\test_location>
<\testname>
<testname=pipe09>
	<description>
		Check that two processes can use the same pipe at the same time.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/pipe/pipe09.c
	<\test_location>
<\testname>
<testname=pipe10>
	<description>
		Check that parent can open a pipe and have a child read from it

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/pipe/pipe10.c
	<\test_location>
<\testname>
<testname=pipe11>
	<description>
		Check if many children can read what is written to a pipe by the
		parent.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/pipe/pipe11.c
	<\test_location>
<\testname>
<testname=poll01>
	<description>
		Verify that valid open file descriptor must be provided to poll() to
		succeed.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/poll/poll01.c
	<\test_location>
<\testname>
<testname=prctl01>
	<description>
		Basic test of prctl().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/prctl/prctl01.c
	<\test_location>
<\testname>
<testname=prctl02>
	<description>
		Test of error conditions for prctl().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/prctl/prctl02.c
	<\test_location>
<\testname>
<testname=pread01>
	<description>
		Verify the functionality of pread() by writing known data using pwrite()
		to the file at various specified offsets and later read from the file from
		various specified offsets, comparing the data read aganist the data
		written.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/pread/pread01.c
	<\test_location>
<\testname>
<testname=pread02>
	<description>
		Verify that,
		1) pread() fails when attempted to read from an unnamed pipe.
		2) pread() fails if the specified offset position was invalid.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/pread/pread02.c
	<\test_location>
<\testname>
<testname=profil01>
	<description>
		Basic test of profil().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/profil/profil01.c
	<\test_location>
<\testname>
<testname=ptrace01>
	<description>
		Functionality test for ptrace(2).

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ptrace/ptrace01.c
	<\test_location>
<\testname>
<testname=ptrace02>
	<description>
		Functionality test for ptrace(2).

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ptrace/ptrace02.c
	<\test_location>
<\testname>
<testname=ptrace3>
	<description>
		Tests for error conditions.

	<\description>
	<test_location>
	<\test_location>
<\testname>
<testname=pwrite01>
	<description>
		Verify the functionality of pwrite() by writing known data using pwrite()
		to the file at various specified offsets and later read from the file from
		various specified offsets, comparing the data written aganist the data
		read using read().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/pwrite/pwrite01.c
	<\test_location>
<\testname>
<testname=pwrite02>
	<description>
		Verify that,
		1) pwrite() fails when attempted to write to an unnamed pipe.
		2) pwrite() fails if the specified offset position was invalid.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/pwrite/pwrite02.c
	<\test_location>
<\testname>
<testname=read01>
	<description>
		Basic test for the read(2) system call

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/read/read01.c
	<\test_location>
<\testname>
<testname=read02>
	<description>
		test 1:
		Does read return -1 if file descriptor is not valid, check for EBADF

		test 2:
		Check if read sets EISDIR, if the fd refers to a directory

		test 3:
		Check if read sets EFAULT, if buf is -1.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/read/read02.c
	<\test_location>
<\testname>
<testname=read03>
	<description>
		Testcase to check that read() sets errno to EAGAIN

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/read/read03.c
	<\test_location>
<\testname>
<testname=read04>
	<description>
		Testcase to check if read returns the number of bytes read correctly.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/read/read04.c
	<\test_location>
<\testname>
<testname=readdir01>
	<description>
		Write multiple files and try to find them with readdir().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/readdir/readdir01.c
	<\test_location>
<\testname>
<testname=readdir02>
	<description>
		Try to readdir with invalid directory stream descriptor dir.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/readdir/readdir02.c
	<\test_location>
<\testname>
<testname=readlink01>
	<description>
		Verify that, readlink will succeed to read the contents of the symbolic
		link created the process.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/readlink/readlink01.c
	<\test_location>
<\testname>
<testname=readlink02>
	<description>
		Basic test for the readlink(2) system call

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/readlink/readlink02.c
	<\test_location>
<\testname>
<testname=readlink03>
	<description>
		Verify that,
		1) readlink(2) returns -1 and sets errno to EACCES if search/write
		permission is denied in the directory where the symbolic link
		resides.
		2) readlink(2) returns -1 and sets errno to EINVAL if the buffer size
		is not positive.
		3) readlink(2) returns -1 and sets errno to EINVAL if the specified
		file is not a symbolic link file.
		4) readlink(2) returns -1 and sets errno to ENAMETOOLONG if the
		pathname component of symbolic link is too long (ie, > PATH_MAX).
		5) readlink(2) returns -1 and sets errno to ENOENT if the component of
		symbolic link points to an empty string.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/readlink/readlink03.c
	<\test_location>
<\testname>
<testname=readlink04>
	<description>
		Verify that, readlink call will succeed to read the contents of the
		symbolic link if invoked by non-root user who is not the owner of the
		symbolic link.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/readlink/readlink04.c
	<\test_location>
<\testname>
<testname=readv01>
	<description>
		Testcase to check the basic functionality of the readv(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/readv/readv01.c
	<\test_location>
<\testname>
<testname=readv02>
	<description>
		Testcase to check the error conditions of the readv(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/readv/readv02.c
	<\test_location>
<\testname>
<testname=reboot01>
	<description>
		Test basic functionality of reboot().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/reboot/reboot01.c
	<\test_location>
<\testname>
<testname=reboot02>
	<description>
		Test error conditions of reboot().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/reboot/reboot02.c
	<\test_location>
<\testname>
<testname=recv01>
	<description>
		Verify that recv() returns the proper errno for various failure cases

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/recv/recv01.c
	<\test_location>
<\testname>
<testname=recvfrom01>
	<description>
		Verify that recvfrom() returns the proper errno for various failure cases

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/recvfrom/recvfrom01.c
	<\test_location>
<\testname>
<testname=recvmsg01>
	<description>
		Verify that recvmsg() returns the proper errno for various failure cases

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/recvmsg/recvmsg01.c
	<\test_location>
<\testname>
<testname=rename01>
	<description>
		This test will verify the rename(2) syscall basic functionality.
		Verify rename() works when the "new" file or directory does not exist.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/rename/rename01.c
	<\test_location>
<\testname>
<testname=rename02>
	<description>
		Basic test for the rename(2) system call

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/rename/rename02.c
	<\test_location>
<\testname>
<testname=rename03>
	<description>
		This test will verify that rename(2) functions correctly
		when the "new" file or directory exists

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/rename/rename03.c
	<\test_location>
<\testname>
<testname=rename04>
	<description>
		This test will verify that rename(2) failed when newpath is
		a non-empty directory and return EEXIST or ENOTEMPTY

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/rename/rename04.c
	<\test_location>
<\testname>
<testname=rename05>
	<description>
		This test will verify that rename(2) fails with EISDIR

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/rename/rename05.c
	<\test_location>
<\testname>
<testname=rename06>
	<description>
		This test will verify that rename(2) failed in EINVAL

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/rename/rename06.c
	<\test_location>
<\testname>
<testname=rename07>
	<description>
		This test will verify that rename(2) failed in ENOTDIR

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/rename/rename07.c
	<\test_location>
<\testname>
<testname=rename08>
	<description>
		This test will verify that rename(2) syscall failed in EFAULT

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/rename/rename08.c
	<\test_location>
<\testname>
<testname=rename09>
	<description>
		check rename() fails with EACCES

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/rename/rename09.c
	<\test_location>
<\testname>
<testname=rename10>
	<description>
		This test will verify that rename(2) syscall fails with ENAMETOOLONG
		and ENOENT

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/rename/rename10.c
	<\test_location>
<\testname>
<testname=rename11>
	<description>
		This test will verify that rename(2) failed in EBUSY

	<\description>
	<test_location>
	<\test_location>
<\testname>
<testname=rename12>
	<description>
		check rename() fails with EPERM

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/rename/rename12.c
	<\test_location>
<\testname>
<testname=rename13>
	<description>
		Verify rename() return successfully and performs no other action
		when "old" file and "new" file link to the same file.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/rename/rename13.c
	<\test_location>
<\testname>
<testname=rmdir01>
	<description>
		This test will verify that rmdir(2) syscall basic functionality.
		verify rmdir(2) returns a value of 0 and the directory being
		removed

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/rmdir/rmdir01.c
	<\test_location>
<\testname>
<testname=rmdir02>
	<description>
		This test will verify that rmdir(2) fail in
		1. ENOTEMPTY
		2. EBUSY
		3. ENAMETOOLONG
		4. ENOENT
		5. ENOTDIR
		6. EFAULT
		7. EFAULT

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/rmdir/rmdir02.c
	<\test_location>
<\testname>
<testname=rmdir03>
	<description>
		check rmdir() fails with EPERM or EACCES

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/rmdir/rmdir03.c
	<\test_location>
<\testname>
<testname=rmdir04>
	<description>
		Basic test for the rmdir(2) system call

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/rmdir/rmdir04.c
	<\test_location>
<\testname>
<testname=rmdir05>
	<description>
		Verify that rmdir(2) returns a value of -1 and sets errno to indicate the error.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/rmdir/rmdir05.c
	<\test_location>
<\testname>
<testname=sbrk01>
	<description>
		Basic test for the sbrk(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sbrk/sbrk01.c
	<\test_location>
<\testname>
<testname=sched_get_priority_max01>
	<description>
		Basic test for sched_get_priority_max().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sched_get_priority_max/sched_get_priority_max01.c
	<\test_location>
<\testname>
<testname=sched_get_priority_max02>
	<description>
		Error condition test for sched_get_priority_max().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sched_get_priority_max/sched_get_priority_max02.c
	<\test_location>
<\testname>
<testname=sched_get_priority_min01>
	<description>
		Basic test for sched_get_priority_min().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sched_get_priority_min/sched_get_priority_min01.c
	<\test_location>
<\testname>
<testname=sched_get_priority_min02>
	<description>
		Error condition test for sched_get_priority_min().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sched_get_priority_min/sched_get_priority_min02.c
	<\test_location>
<\testname>
<testname=sched_getparam01>
	<description>
		Basic test for sched_getparam(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sched_getparam/sched_getparam01.c
	<\test_location>
<\testname>
<testname=sched_getparam02>
	<description>
		Get scheduling parametes for parent process

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sched_getparam/sched_getparam02.c
	<\test_location>
<\testname>
<testname=sched_getparam03>
	<description>
		Testing error conditions for sched_getparam(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sched_getparam/sched_getparam03.c
	<\test_location>
<\testname>
<testname=sched_getscheduler01>
	<description>
		Testcase to check sched_getscheduler() returns correct return value

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sched_getscheduler/sched_getscheduler01.c
	<\test_location>
<\testname>
<testname=sched_getscheduler02>
	<description>
		To check for the errno ESRCH

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sched_getscheduler/sched_getscheduler02.c
	<\test_location>
<\testname>
<testname=sched_rr_get_interval01>
	<description>
		Basic test for sched_rr_get_interval(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sched_rr_get_interval/sched_rr_get_interval01.c
	<\test_location>
<\testname>
<testname=sched_rr_get_interval02>
	<description>
		Functionality test

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sched_rr_get_interval/sched_rr_get_interval02.c
	<\test_location>
<\testname>
<testname=sched_rr_get_interval03>
	<description>
		Tests for error conditions

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sched_rr_get_interval/sched_rr_get_interval03.c
	<\test_location>
<\testname>
<testname=sched_setparam01>
	<description>
		Basic test for sched_setparam(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sched_setparam/sched_setparam01.c
	<\test_location>
<\testname>
<testname=sched_setparam02>
	<description>
		Checks functionality for sched_setparam(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sched_setparam/sched_setparam02.c
	<\test_location>
<\testname>
<testname=sched_setparam03>
	<description>
		Checks functionality for sched_setparam(2) for pid!=0

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sched_setparam/sched_setparam03.c
	<\test_location>
<\testname>
<testname=sched_setparam04>
	<description>
		Testing error conditions for sched_setparam(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sched_setparam/sched_setparam04.c
	<\test_location>
<\testname>
<testname=sched_setparam05>
	<description>
		Verify that sched_setparam() fails if the user does

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sched_setparam/sched_setparam05.c
	<\test_location>
<\testname>
<testname=sched_setscheduler01>
	<description>
		Testcase to test whether sched_setscheduler(2) sets the errnos
		correctly.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sched_setscheduler/sched_setscheduler01.c
	<\test_location>
<\testname>
<testname=sched_setscheduler02>
	<description>
		Testcase to test whether sched_setscheduler(2) sets the errnos
		correctly.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sched_setscheduler/sched_setscheduler02.c
	<\test_location>
<\testname>
<testname=sched_yield01>
	<description>
		Testcase to check that sched_yield returns correct values.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sched_yield/sched_yield01.c
	<\test_location>
<\testname>
<testname=select01>
	<description>
		Basic test for the select(2) system call to a fd of regular file with no I/O
		and small timeout

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/select/select01.c
	<\test_location>
<\testname>
<testname=select02>
	<description>
		Basic test for the select(2) system call to fd of system pipe with no I/O
		and small timeout

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/select/select02.c
	<\test_location>
<\testname>
<testname=select03>
	<description>
		Basic test for the select(2) system call to fd of a named-pipe (FIFO)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/select/select03.c
	<\test_location>
<\testname>
<testname=select04>
	<description>
		Verify that select(2) returns immediately (does not block) if the
		timeout value is zero.

	<\description>
	<test_location>
	<\test_location>
<\testname>
<testname=select05>
	<description>
		Verify that select(2) fails when one or more of the file descriptor sets
		specify a file descriptor which is not valid.

	<\description>
	<test_location>
	<\test_location>
<\testname>
<testname=select06>
	<description>
		Verify that select(2) fails when a signal is delivered before any of the
		selected events occur and before the timeout interval expires.

	<\description>
	<test_location>
	<\test_location>
<\testname>
<testname=select07>
	<description>
		Verify that select(2) fails when an invalid timeout interval is specified.

	<\description>
	<test_location>
	<\test_location>
<\testname>
<testname=select08>
	<description>
		Verify the functionality of select(2) by passing non-null writefds
		which points to a regular file, pipes or FIFO's.

	<\description>
	<test_location>
	<\test_location>
<\testname>
<testname=select09>
	<description>
		Verify the functionality of select(2) by passing non-null readfds
		which points to a regular file, pipes or FIFO's.

	<\description>
	<test_location>
	<\test_location>
<\testname>
<testname=select10>
	<description>
		Verify that a successful call to select() shall return the desired
		number of modified descriptors for which bits are set in the bit masks,
		where descriptors points to a regular file, pipes or FIFO's.

	<\description>
	<test_location>
	<\test_location>
<\testname>
<testname=send01>
	<description>
		Verify that send() returns the proper errno for various failure cases

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/send/send01.c
	<\test_location>
<\testname>
<testname=sendfile02>
	<description>
		Testcase to test the basic functionality of the sendfile(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sendfile/sendfile02.c
	<\test_location>
<\testname>
<testname=sendfile03>
	<description>
		Testcase to test that sendfile(2) system call returns appropriete
		errnos on error.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sendfile/sendfile03.c
	<\test_location>
<\testname>
<testname=sendmsg01>
	<description>
		Verify that sendmsg() returns the proper errno for various failure cases

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sendmsg/sendmsg01.c
	<\test_location>
<\testname>
<testname=sendto01>
	<description>
		Verify that sendto() returns the proper errno for various failure cases

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sendto/sendto01.c
	<\test_location>
<\testname>
<testname=setdomainname01>
	<description>
		Basic test for setdomainame(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setdomainname/setdomainname01.c
	<\test_location>
<\testname>
<testname=setdomainname02>
	<description>
		Test for checking error conditions for setdomainame(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setdomainname/setdomainname02.c
	<\test_location>
<\testname>
<testname=setdomainname03>
	<description>
		Test for EPERM error value when run as non superuser

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setdomainname/setdomainname03.c
	<\test_location>
<\testname>
<testname=setegid01>
	<description>
		Verify that setegid does not modify the saved gid or real gid.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setegid/setegid01.c
	<\test_location>
<\testname>
<testname=setfsgid01>
	<description>
		Testcase to check the basic functionality of setfsgid(2) system
		call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setfsgid/setfsgid01.c
	<\test_location>
<\testname>
<testname=setfsuid01>
	<description>
		Testcase to test the basic functionality of the setfsuid(2) system
		call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setfsuid/setfsuid01.c
	<\test_location>
<\testname>
<testname=setgid01>
	<description>
		Basic test for the setgid(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setgid/setgid01.c
	<\test_location>
<\testname>
<testname=setgid02>
	<description>
		Testcase to ensure that the setgid() system call sets errno to EPERM

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setgid/setgid02.c
	<\test_location>
<\testname>
<testname=setgroups01>
	<description>
		Basic test for the setgroups(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setgroups/setgroups01.c
	<\test_location>
<\testname>
<testname=setgroups02>
	<description>
		Verify that,
		1. setgroups() fails with -1 and sets errno to EINVAL if the size
		argument value is > NGROUPS
		2. setgroups() fails with -1 and sets errno to EPERM if the
		calling process is not super-user.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setgroups/setgroups02.c
	<\test_location>
<\testname>
<testname=setgroups03>
	<description>
		Verify that, only root process can invoke setgroups() system call to
		set the supplementary group IDs of the process.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setgroups/setgroups03.c
	<\test_location>
<\testname>
<testname=setitimer01>
	<description>
		check that a resonable setitimer() call succeeds.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setitimer/setitimer01.c
	<\test_location>
<\testname>
<testname=setitimer02>
	<description>
		check that a setitimer() call fails as expected
		with incorrect values.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setitimer/setitimer02.c
	<\test_location>
<\testname>
<testname=setitimer03>
	<description>
		check that a setitimer() call fails as expected
		with incorrect values.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setitimer/setitimer03.c
	<\test_location>
<\testname>
<testname=setpgid01>
	<description>
		Basic test for setpgid(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setpgid/setpgid01.c
	<\test_location>
<\testname>
<testname=setpgid02>
	<description>
		Testcase to check that setpgid() sets errno correctly.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setpgid/setpgid02.c
	<\test_location>
<\testname>
<testname=setpgid03>
	<description>
		Test to check the error and trivial conditions in setpgid system call

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setpgid/setpgid03.c
	<\test_location>
<\testname>
<testname=setpgrp01>
	<description>
		Basic test for the setpgrp(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setpgrp/setpgrp01.c
	<\test_location>
<\testname>
<testname=setpgrp02>
	<description>
		Testcase to check the basic functionality of the setpgrp(2) syscall.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setpgrp/setpgrp02.c
	<\test_location>
<\testname>
<testname=setpriority01>
	<description>
		set the priority for the test process lower.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setpriority/setpriority01.c
	<\test_location>
<\testname>
<testname=setpriority02>
	<description>
		test for an expected failure by trying to raise
		the priority for the test process while not having
		permissions to do so.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setpriority/setpriority02.c
	<\test_location>
<\testname>
<testname=setpriority03>
	<description>
		test for an expected failure by using an invalid
		PRIO value
		setpriority04

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setpriority/setpriority03.c
	<\test_location>
<\testname>
<testname=setpriority04>
	<description>
		test for an expected failure by using an invalid
		process id

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setpriority/setpriority04.c
	<\test_location>
<\testname>
<testname=setpriority05>
	<description>
		test for an expected failure by trying to change
		a process with an ID that is different from the
		test process

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setpriority/setpriority05.c
	<\test_location>
<\testname>
<testname=setregid01>
	<description>
		Basic test for the setregid(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setregid/setregid01.c
	<\test_location>
<\testname>
<testname=setregid02>
	<description>
		Test that setregid() fails and sets the proper errno values when a
		non-root user attemps to change the real or effective group id to a
		value other than the current gid or the current effective gid.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setregid/setregid02.c
	<\test_location>
<\testname>
<testname=setregid03>
	<description>
		Test setregid() when executed by a non-root user.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setregid/setregid03.c
	<\test_location>
<\testname>
<testname=setregid04>
	<description>
		Test setregid() when executed by root.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setregid/setregid04.c
	<\test_location>
<\testname>
<testname=setresgid01>
	<description>
		Checks functionality of setresgid(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setresgid/setresgid01.c
	<\test_location>
<\testname>
<testname=setresgid02>
	<description>
		Checks functionality of setresgid(2) for non-root group id.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setresgid/setresgid02.c
	<\test_location>
<\testname>
<testname=setresgid03>
	<description>
		Checks error conditions for setresgid(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setresgid/setresgid03.c
	<\test_location>
<\testname>
<testname=setresuid01>
	<description>
		Test setresuid() when executed by root.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setresuid/setresuid01.c
	<\test_location>
<\testname>
<testname=setresuid02>
	<description>
		Test that a non-root user can change the real, effective and saved
		uid values through the setresuid system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setresuid/setresuid02.c
	<\test_location>
<\testname>
<testname=setresuid03>
	<description>
		Test that the setresuid system call sets the proper errno
		values when a non-root user attempts to change the real, effective or
		saved uid to a value other than one of the current uid, the current
		effective uid of the current saved uid. Also verify that setresuid
		fails if an invalid uid value is given.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setresuid/setresuid03.c
	<\test_location>
<\testname>
<testname=setreuid01>
	<description>
		Basic test for the setreuid(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setreuid/setreuid01.c
	<\test_location>
<\testname>
<testname=setreuid02>
	<description>
		Test setreuid() when executed by root.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setreuid/setreuid02.c
	<\test_location>
<\testname>
<testname=setreuid03>
	<description>
		Test setreuid() when executed by an unpriviledged user.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setreuid/setreuid03.c
	<\test_location>
<\testname>
<testname=setreuid04>
	<description>
		Test that root can change the real and effective uid to an
		unpriviledged user.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setreuid/setreuid04.c
	<\test_location>
<\testname>
<testname=setreuid05>
	<description>
		Test the setreuid() feature, verifying the role of the saved-set-uid
		and setreuid's effect on it.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setreuid/setreuid05.c
	<\test_location>
<\testname>
<testname=setreuid06>
	<description>
		Test that EINVAL is set when setreuid is given an invalid user id.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setreuid/setreuid06.c
	<\test_location>
<\testname>
<testname=setrlimit01>
	<description>
		Testcase to check the basic functionality of the setrlimit system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setrlimit/setrlimit01.c
	<\test_location>
<\testname>
<testname=setrlimit02>
	<description>
		Testcase to test the different errnos set by setrlimit(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setrlimit/setrlimit02.c
	<\test_location>
<\testname>
<testname=setrlimit03>
	<description>
		Test for EPERM when the super-user tries to increase RLIMIT_NOFILE
		beyond the system limit.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setrlimit/setrlimit03.c
	<\test_location>
<\testname>
<testname=setsid01>
	<description>
		Test to check the error and trivial conditions in setsid system call

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setsid/setsid01.c
	<\test_location>
<\testname>
<testname=setsockopt01>
	<description>
		Verify that setsockopt() returns the proper errno for various failure cases

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setsockopt/setsockopt01.c
	<\test_location>
<\testname>
<testname=settimeofday01>
	<description>
		Testcase to check the basic functionality of settimeofday().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/settimeofday/settimeofday01.c
	<\test_location>
<\testname>
<testname=settimeofday02>
	<description>
		Testcase to check that settimeofday() sets errnos correctly.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/settimeofday/settimeofday02.c
	<\test_location>
<\testname>
<testname=setuid01>
	<description>
		Basic test for the setuid(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setuid/setuid01.c
	<\test_location>
<\testname>
<testname=setuid02>
	<description>
		Basic test for the setuid(2) system call as root.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setuid/setuid02.c
	<\test_location>
<\testname>
<testname=setuid03>
	<description>
		Test to check the error and trivial conditions in setuid

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/setuid/setuid03.c
	<\test_location>
<\testname>
<testname=sigaction01>
	<description>
		Test some features of sigaction (see below for more details)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sigaction/sigaction01.c
	<\test_location>
<\testname>
<testname=sigaction02>
	<description>
		Testcase to check the basic errnos set by the sigaction(2) syscall.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sigaction/sigaction02.c
	<\test_location>
<\testname>
<testname=sigaltstack01>
	<description>
		Send a signal using the main stack. While executing the signal handler
		compare a variable's address lying on the main stack with the stack
		boundaries returned by sigaltstack().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sigaltstack/sigaltstack01.c
	<\test_location>
<\testname>
<testname=sigaltstack02>
	<description>
		Verify that,
		1. sigaltstack() fails and sets errno to EINVAL when "ss_flags" field
		pointed to by 'ss' contains invalid flags.
		2. sigaltstack() fails and sets errno to ENOMEM when the size of alternate
		stack area is less than MINSIGSTKSZ.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sigaltstack/sigaltstack02.c
	<\test_location>
<\testname>
<testname=sighold02>
	<description>
		Basic test for the sighold02(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sighold/sighold02.c
	<\test_location>
<\testname>
<testname=signal01>
	<description>
		set the signal handler to our own function

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/signal/signal01.c
	<\test_location>
<\testname>
<testname=signal02>
	<description>
		Test that we get an error using illegal signals

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/signal/signal02.c
	<\test_location>
<\testname>
<testname=signal03>
	<description>
		Boundary value and other invalid value checking of signal setup and signal
		sending.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/signal/signal03.c
	<\test_location>
<\testname>
<testname=signal04>
	<description>
		restore signals to default behavior

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/signal/signal04.c
	<\test_location>
<\testname>
<testname=signal03>
	<description>
		set signals to be ignored

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/signal/signal03.c
	<\test_location>
<\testname>
<testname=sigpending02>
	<description>
		Test to see that the proper errors are returned by sigpending.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sigpending/sigpending02.c
	<\test_location>
<\testname>
<testname=sigprocmask01>
	<description>
		Verify that sigprocmask() succeeds to examine and change the calling
		process's signal mask.
		Also, verify that sigpending() succeeds to store signal mask that are
		blocked from delivery and pending for the calling process.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sigprocmask/sigprocmask01.c
	<\test_location>
<\testname>
<testname=sigrelse01>
	<description>
		Basic test for the sigrelse(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sigrelse/sigrelse01.c
	<\test_location>
<\testname>
<testname=sigsuspend01>
	<description>
		Verify that sigsuspend() succeeds to change process's current signal
		mask with the specified signal mask and suspends the process execution
		until the delivery of a signal.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sigsuspend/sigsuspend01.c
	<\test_location>
<\testname>
<testname=socket01>
	<description>
		Verify that socket() returns the proper errno for various failure cases

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/socket/socket01.c
	<\test_location>
<\testname>
<testname=socketcall01>
	<description>
		Basic test for socketcall(2) for socket(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/socketcall/socketcall01.c
	<\test_location>
<\testname>
<testname=socketcall02>
	<description>
		Error test for socketcall(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/socketcall/socketcall02.c
	<\test_location>
<\testname>
<testname=socketcall03>
	<description>
		Basic test for socketcall(2) for bind(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/socketcall/socketcall03.c
	<\test_location>
<\testname>
<testname=socketcall04>
	<description>
		Basic test for socketcall(2) for listen(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/socketcall/socketcall04.c
	<\test_location>
<\testname>
<testname=socketpair01>
	<description>
		Verify that socketpair() returns the proper errno for various
		failure cases

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/socketpair/socketpair01.c
	<\test_location>
<\testname>
<testname=socketpair01>
	<description>
		Verify that socketpair() returns the proper errno for various failure cases

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/socketpair/socketpair01.c
	<\test_location>
<\testname>
<testname=sockioctl01>
	<description>
		Verify that ioctl() on sockets returns the proper errno for various
		failure cases

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sockioctl/sockioctl01.c
	<\test_location>
<\testname>
<testname=stat01>
	<description>
		Verify that, stat(2) succeeds to get the status of a file and fills the
		stat structure elements.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/stat/stat01.c
	<\test_location>
<\testname>
<testname=stat02>
	<description>
		Verify that, stat(2) succeeds to get the status of a file and fills the
		stat structure elements though process doesn't have read access to the
		file.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/stat/stat02.c
	<\test_location>
<\testname>
<testname=stat03>
	<description>
		Verify that,
		1) stat(2) returns -1 and sets errno to EACCES if search permission is
		denied on a component of the path prefix.
		2) stat(2) returns -1 and sets errno to ENOENT if the specified file
		does not exists or empty string.
		3) stat(2) returns -1 and sets errno to EFAULT if pathname points
		outside user's accessible address space.
		4) stat(2) returns -1 and sets errno to ENAMETOOLONG if the pathname
		component is too long.
		5) stat(2) returns -1 and sets errno to ENOTDIR if the directory
		component in pathname is not a directory.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/stat/stat03.c
	<\test_location>
<\testname>
<testname=stat05>
	<description>
		Basic test for the stat05(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/stat/stat05.c
	<\test_location>
<\testname>
<testname=statfs01>
	<description>
		Basic test for the statfs(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/statfs/statfs01.c
	<\test_location>
<\testname>
<testname=statfs02>
	<description>
		Testcase to check that statfs(2) sets errno correctly.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/statfs/statfs02.c
	<\test_location>
<\testname>
<testname=stime01>
	<description>
		Verify that the system call stime() successfully sets the system's idea
		of data and time if invoked by "root" user.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/stime/stime01.c
	<\test_location>
<\testname>
<testname=stime02>
	<description>
		Verify that the system call stime() fails to set the system's idea
		of data and time if invoked by "non-root" user.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/stime/stime02.c
	<\test_location>
<\testname>
<testname=string01>
	<description>
		Test string functions.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/string/string01.c
	<\test_location>
<\testname>
<testname=swapoff01>
	<description>
		Basic test for swapoff(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/swapoff/swapoff01.c
	<\test_location>
<\testname>
<testname=swapoff02>
	<description>
		Test checking for basic error conditions

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/swapoff/swapoff02.c
	<\test_location>
<\testname>
<testname=swapon01>
	<description>
		Basic test for swapon(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/swapon/swapon01.c
	<\test_location>
<\testname>
<testname=swapon02>
	<description>
		Test checking for basic error conditions

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/swapon/swapon02.c
	<\test_location>
<\testname>
<testname=symlink01>
	<description>
		Test of various file function calls, such as rename or open, on a symbolic
		link file.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/symlink/symlink01.c
	<\test_location>
<\testname>
<testname=symlink02>
	<description>
		Basic test for the symlink(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/symlink/symlink02.c
	<\test_location>
<\testname>
<testname=symlink03>
	<description>
		Verify that,
		1) symlink(2) returns -1 and sets errno to EACCES if search/write
		permission is denied in the directory where the symbolic link is
		being created.
		2) symlink(2) returns -1 and sets errno to EEXIST if the specified
		symbolic link already exists.
		3) symlink(2) returns -1 and sets errno to EFAULT if the specified
		file or symbolic link points to invalid address.
		4) symlink(2) returns -1 and sets errno to ENAMETOOLONG if the
		pathname component of symbolic link is too long (ie, > PATH_MAX).
		5) symlink(2) returns -1 and sets errno to ENOTDIR if the directory
		component in pathname of symbolic link is not a directory.
		6) symlink(2) returns -1 and sets errno to ENOENT if the component of
		symbolic link points to an empty string.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/symlink/symlink03.c
	<\test_location>
<\testname>
<testname=symlink04>
	<description>
		Verify that, symlink will succeed to creat a symbolic link of an existing
		object name path.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/symlink/symlink04.c
	<\test_location>
<\testname>
<testname=symlink05>
	<description>
		Verify that, symlink will succeed to creat a symbolic link of an
		non-existing object name path.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/symlink/symlink05.c
	<\test_location>
<\testname>
<testname=sync01>
	<description>
		Basic test for the sync(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sync/sync01.c
	<\test_location>
<\testname>
<testname=sync02>
	<description>
		Open a file for write; modify the file, then do a sync().
		Verify that the data has been written to disk by re-opening the file.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sync/sync02.c
	<\test_location>
<\testname>
<testname=syscall01>
	<description>
		Basic test for the syscall() system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/syscall/syscall01.c
	<\test_location>
<\testname>
<testname=sysconf01>
	<description>
		Basic test for the sysconf() system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sysconf/sysconf01.c
	<\test_location>
<\testname>
<testname=sysctl01>
	<description>
		Testcase for testing the basic functionality of sysctl(2) system call.
		This testcase attempts to read the kernel parameters using
		sysctl({CTL_KERN, KERN_ }, ...) and compares it with the known
		values.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sysctl/sysctl01.c
	<\test_location>
<\testname>
<testname=sysctl03>
	<description>
		Testcase to check that sysctl(2) sets errno to EPERM correctly.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sysctl/sysctl03.c
	<\test_location>
<\testname>
<testname=sysctl04>
	<description>
		Testcase to check that sysctl(2) sets errno to ENOTDIR

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sysctl/sysctl04.c
	<\test_location>
<\testname>
<testname=sysctl05>
	<description>
		Testcase to check that sysctl(2) sets errno to EFAULT

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sysctl/sysctl05.c
	<\test_location>
<\testname>
<testname=sysfs01>
	<description>
		Basic test for sysfs(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sysfs/sysfs01.c
	<\test_location>
<\testname>
<testname=sysfs02>
	<description>
		Basic test for sysfs(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sysfs/sysfs02.c
	<\test_location>
<\testname>
<testname=sysfs03>
	<description>
		Basic test for sysfs(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sysfs/sysfs03.c
	<\test_location>
<\testname>
<testname=sysfs04>
	<description>
		Test checking for basic error conditions

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sysfs/sysfs04.c
	<\test_location>
<\testname>
<testname=sysfs05>
	<description>
		Test checking for basic error conditions

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sysfs/sysfs05.c
	<\test_location>
<\testname>
<testname=sysfs06>
	<description>
		Test checking for basic error conditions

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sysfs/sysfs06.c
	<\test_location>
<\testname>
<testname=sysinfo01>
	<description>
		Verify that sysinfo() succeeds to get the system information and fills
		the structure passed.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sysinfo/sysinfo01.c
	<\test_location>
<\testname>
<testname=sysinfo02>
	<description>
		Verify that sysinfo() returns the correct error for an invalid address structure.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/sysinfo/sysinfo02.c
	<\test_location>
<\testname>
<testname=syslog01>
	<description>
		Test whether messages are logged to the specified file

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/syslog/syslog01
	<\test_location>
<\testname>
<testname=syslog02>
	<description>
		Test if messages of all levels are logged.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/syslog/syslog02
	<\test_location>
<\testname>
<testname=syslog03>
	<description>
		Do openlog(), log the messages and see whether
		ident string is prepended to the message.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/syslog/syslog03
	<\test_location>
<\testname>
<testname=syslog04>
	<description>
		Test the logging option: LOG_PID

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/syslog/syslog04
	<\test_location>
<\testname>
<testname=syslog05>
	<description>
		Test the logging option: LOG_CONS

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/syslog/syslog05
	<\test_location>
<\testname>
<testname=syslog06>
	<description>
		Test the logging option: LOG_NDELAY

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/syslog/syslog06
	<\test_location>
<\testname>
<testname=syslog07>
	<description>
		Test the priorities.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/syslog/syslog07
	<\test_location>
<\testname>
<testname=syslog08>
	<description>
		Test all the facilities at a particular level.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/syslog/syslog08
	<\test_location>
<\testname>
<testname=syslog09>
	<description>
		Test setlogmask() with LOG_UPTO macro.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/syslog/syslog09
	<\test_location>
<\testname>
<testname=syslog10>
	<description>
		Test setlogmask() with LOG_MASK macro.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/syslog/syslog10
	<\test_location>
<\testname>
<testname=syslog11>
	<description>
		Basic test for syslog() function call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/syslog/syslog11.c
	<\test_location>
<\testname>
<testname=syslog12>
	<description>
		Check error conditions for syscall().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/syslog/syslog12.c
	<\test_location>
<\testname>
<testname=time01>
	<description>
		Basic test for the time(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/time/time01.c
	<\test_location>
<\testname>
<testname=time02>
	<description>
		Verify that time(2) returns the value of time in seconds since
		the Epoch and stores this value in the memory pointed to by the parameter.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/time/time02.c
	<\test_location>
<\testname>
<testname=times01>
	<description>
		Basic test for the times(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/times/times01.c
	<\test_location>
<\testname>
<testname=times03>
	<description>
		Testcase to check the basic functionality of the times() system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/times/times03.c
	<\test_location>
<\testname>
<testname=truncate01>
	<description>
		Verify that, truncate(2) succeeds to truncate a file to a specified
		length.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/truncate/truncate01.c
	<\test_location>
<\testname>
<testname=truncate02>
	<description>
		Verify that, truncate(2) succeeds to truncate a file to a certain length,
		but the attempt to read past the truncated length will fail.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/truncate/truncate02.c
	<\test_location>
<\testname>
<testname=truncate03>
	<description>
		Verify that,
		1) truncate(2) returns -1 and sets errno to EACCES if search/write
		permission denied for the process on the component of the path prefix
		or named file.
		2) truncate(2) returns -1 and sets errno to ENOTDIR if the component of
		the path prefix is not a directory.
		3) truncate(2) returns -1 and sets errno to EFAULT if pathname points
		outside user's accessible address space.
		4) truncate(2) returns -1 and sets errno to ENAMETOOLONG if the component
		of a pathname exceeded 255 characters or entire pathname exceeds 1023
		characters.
		5) truncate(2) returns -1 and sets errno to ENOENT if the named file
		does not exist.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/truncate/truncate03.c
	<\test_location>
<\testname>
<testname=ulimit01>
	<description>
		Basic test for the ulimit(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ulimit/ulimit01.c
	<\test_location>
<\testname>
<testname=umask01>
	<description>
		Basic test for the umask(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/umask/umask01.c
	<\test_location>
<\testname>
<testname=umask02>
	<description>
		Check that umask changes the mask, and that the previous
		value of the mask is returned correctly for each value.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/umask/umask02.c
	<\test_location>
<\testname>
<testname=umask03>
	<description>
		Check that umask changes the mask, and that the previous
		value of the mask is returned correctly for each value.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/umask/umask03.c
	<\test_location>
<\testname>
<testname=umount01>
	<description>
		Basic test for umount(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/umount/umount01.c
	<\test_location>
<\testname>
<testname=umount02>
	<description>
		Test for checking basic error conditions for umount(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/umount/umount02.c
	<\test_location>
<\testname>
<testname=umount03>
	<description>
		Test for checking EPERM

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/umount/umount03.c
	<\test_location>
<\testname>
<testname=umount04>
	<description>
		Test for checking EACCES

	<\description>
	<test_location>
	<\test_location>
<\testname>
<testname=uname01>
	<description>
		Basic test for the uname(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/uname/uname01.c
	<\test_location>
<\testname>
<testname=uname02>
	<description>
		Call uname() with an invalid address to produce a failure

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/uname/uname02.c
	<\test_location>
<\testname>
<testname=uname03>
	<description>
		Call uname() and make sure it succeeds

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/uname/uname03.c
	<\test_location>
<\testname>
<testname=unlink05>
	<description>
		Basic test for the unlink(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/unlink/unlink05.c
	<\test_location>
<\testname>
<testname=unlink06>
	<description>
		Test for the unlink(2) system call of a FIFO.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/unlink/unlink06.c
	<\test_location>
<\testname>
<testname=unlink07>
	<description>
		Tests for error handling for the unlink(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/unlink/unlink07.c
	<\test_location>
<\testname>
<testname=unlink08>
	<description>
		More tests for error handling for the unlink(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/unlink/unlink08.c
	<\test_location>
<\testname>
<testname=ustat01>
	<description>
		Basic test for the ustat() system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ustat/ustat01.c
	<\test_location>
<\testname>
<testname=ustat02>
	<description>
		Test for error conditions of ustat().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/ustat/ustat02.c
	<\test_location>
<\testname>
<testname=utime01>
	<description>
		Verify that the system call utime() successfully sets the modification
		and access times of a file to the current time, if the times argument
		is null, and the user ID of the process is "root".

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/utime/utime01.c
	<\test_location>
<\testname>
<testname=utime02>
	<description>
		Verify that the system call utime() successfully sets the modification
		and access times of a file to the current time, under the following
		constraints,
		- The times argument is null.
		- The user ID of the process is not "root".
		- The file is owned by the user ID of the process.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/utime/utime02.c
	<\test_location>
<\testname>
<testname=utime03>
	<description>
		Verify that the system call utime() successfully sets the modification
		and access times of a file to the current time, under the following
		constraints,
		- The times argument is null.
		- The user ID of the process is not "root".
		- The file is not owned by the user ID of the process.
		- The user ID of the process has write access to the file.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/utime/utime03.c
	<\test_location>
<\testname>
<testname=utime04>
	<description>
		Verify that the system call utime() successfully sets the modification
		and access times of a file to the time specified by times argument, if
		the times argument is not null, and the user ID of the process is "root".

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/utime/utime04.c
	<\test_location>
<\testname>
<testname=utime05>
	<description>
		Verify that the system call utime() successfully sets the modification
		and access times of a file to the value specified by the times argument
		under the following constraints,
		- The times argument is not null,
		- The user ID of the process is not "root".
		- The file is owned by the user ID of the process.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/utime/utime05.c
	<\test_location>
<\testname>
<testname=utime06>
	<description>
		1. Verify that the system call utime() fails to set the modification
		and access times of a file to the current time, under the following
		constraints,

		The times argument is null.

		The user ID of the process is not "root".

		The file is not owned by the user ID of the process.

		The user ID of the process does not have write access to the
		file.
		2. Verify that the system call utime() fails to set the modification
		and access times of a file if the specified file doesn't exist.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/utime/utime06.c
	<\test_location>
<\testname>
<testname=vfork01>
	<description>
		Fork a process using vfork() and verify that, the attribute values like
		euid, ruid, suid, egid, rgid, sgid, umask, inode and device number of
		root and current working directories are same as that of the parent
		process.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/vfork/vfork01.c
	<\test_location>
<\testname>
<testname=vfork02>
	<description>
		Fork a process using vfork() and verify that, the pending signals in
		the parent are not pending in the child process.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/vfork/vfork02.c
	<\test_location>
<\testname>
<testname=vhangup01>
	<description>
		Check the return value, and errno of vhangup(2)
		when a non-root user calls vhangup().

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/vhangup/vhangup01.c
	<\test_location>
<\testname>
<testname=vhangup02>
	<description>
		To test the basic functionality of vhangup(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/vhangup/vhangup02.c
	<\test_location>
<\testname>
<testname=wait02>
	<description>
		Basic test for wait(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/wait/wait02.c
	<\test_location>
<\testname>
<testname=wait401>
	<description>
		check that a call to wait4() correctly waits for a child
		process to exit

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/wait4/wait401.c
	<\test_location>
<\testname>
<testname=wait402>
	<description>
		check for ECHILD errno when using an illegal pid value

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/wait4/wait402.c
	<\test_location>
<\testname>
<testname=waitpid01>
	<description>
		Check that when a child kills itself by generating an alarm
		exception, the waiting parent is correctly notified.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/waitpid/waitpid01.c
	<\test_location>
<\testname>
<testname=waitpid02>
	<description>
		Check that when a child kills itself by generating an integer zero
		divide exception, the waiting parent is correctly notified.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/waitpid/waitpid02.c
	<\test_location>
<\testname>
<testname=waitpid03>
	<description>
		Check that parent waits unitl specific child has returned.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/waitpid/waitpid03.c
	<\test_location>
<\testname>
<testname=waitpid04>
	<description>
		test to check the error conditions in waitpid sys call

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/waitpid/waitpid04.c
	<\test_location>
<\testname>
<testname=waitpid05>
	<description>
		Check that when a child kills itself with a kill statement after
		determining its process id by using getpid, the parent receives a
		correct report of the cause of its death. This also indirectly
		checks that getpid returns the correct process id.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/waitpid/waitpid05.c
	<\test_location>
<\testname>
<testname=waitpid06>
	<description>
		Tests to see if pid's returned from fork and waitpid are same.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/waitpid/waitpid06.c
	<\test_location>
<\testname>
<testname=waitpid07>
	<description>
		Tests to see if pid's returned from fork and waitpid are same.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/waitpid/waitpid07.c
	<\test_location>
<\testname>
<testname=waitpid08>
	<description>
		Tests to see if pid's returned from fork and waitpid are same

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/waitpid/waitpid08.c
	<\test_location>
<\testname>
<testname=waitpid09>
	<description>
		Check ability of parent to wait until child returns, and that the
		child's process id is returned through the waitpid. Check that
		waitpid returns immediately if no child is present.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/waitpid/waitpid09.c
	<\test_location>
<\testname>
<testname=waitpid10>
	<description>
		Tests to see if pid's returned from fork and waitpid are same

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/waitpid/waitpid10.c
	<\test_location>
<\testname>
<testname=waitpid11>
	<description>
		Tests to see if pid's returned from fork and waitpid are same

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/waitpid/waitpid11.c
	<\test_location>
<\testname>
<testname=waitpid12>
	<description>
		Tests to see if pid's returned from fork and waitpid are same

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/waitpid/waitpid12.c
	<\test_location>
<\testname>
<testname=waitpid13>
	<description>
		Tests to see if pid's returned from fork and waitpid are same

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/waitpid/waitpid13.c
	<\test_location>
<\testname>
<testname=write01>
	<description>
		Basic test for write(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/write/write01.c
	<\test_location>
<\testname>
<testname=write02>
	<description>
		Basic functionality test: does the return from write match the count
		of the number of bytes written.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/write/write02.c
	<\test_location>
<\testname>
<testname=write03>
	<description>
		Testcase to check that write(2) doesn't corrupt a file when it fails

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/write/write03.c
	<\test_location>
<\testname>
<testname=write04>
	<description>
		Testcase to check that write() sets errno to EAGAIN

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/write/write04.c
	<\test_location>
<\testname>
<testname=write05>
	<description>
		Check the return value, and errnos of write(2)
		- when the file descriptor is invalid

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/write/write05.c
	<\test_location>
<\testname>
<testname=EBADF>
	<description>
		- when the buf parameter is invalid

	<\description>
	<test_location>
	<\test_location>
<\testname>
<testname=EFAULT>
	<description>
		- on an attempt to write to a pipe that is not open for reading

	<\description>
	<test_location>
	<\test_location>
<\testname>
<testname=writev01>
	<description>
		Testcase to check the basic functionality of writev(2) system call.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/writev/writev01.c
	<\test_location>
<\testname>
<testname=writev02>
	<description>
		In these testcases, writev() is called with partially valid data
		to be written in a sparse file.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/writev/writev02.c
	<\test_location>
<\testname>
<testname=writev03>
	<description>
		The testcases are written calling writev() with partially valid data
		to overwrite the contents, to write in the beginning and to write in
		the end of the file.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/writev/writev03.c
	<\test_location>
<\testname>
<testname=writev04>
	<description>
		The testcases are written calling writev() with partially valid data
		to overwrite the contents, to write in the beginning and to write in
		the end of the file. This is same as writev03, but the length of
		buffer used here is 8192 bytes.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/writev/writev04.c
	<\test_location>
<\testname>
<testname=writev05>
	<description>
		These testcases are written to test writev() on sparse files. This
		is same as writev02. But the initial write() with valid data is
		done at the beginning of the file.

	<\description>
	<test_location>
		ltp/testcases/kernel/syscalls/writev/writev05.c
	<\test_location>
<\testname>
<testname=clock_gettime02>
	<description>
		Basic test for clock_gettime(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/timers/clock_gettime/clock_gettime02.c
	<\test_location>
<\testname>
<testname=clock_gettime03>
	<description>
		Test checking for basic error conditions for clock_gettime(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/timers/clock_gettime/clock_gettime03.c
	<\test_location>
<\testname>
<testname=clock_settime02>
	<description>
		Basic test for clock_settime(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/timers/clock_settime/clock_settime02.c
	<\test_location>
<\testname>
<testname=clock_settime03>
	<description>
		Test checking for basic error conditions for clock_settime(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/timers/clock_settime/clock_settime03.c
	<\test_location>
<\testname>
<testname=timer_create01>
	<description>
		Basic test for timer_create(2)

	<\description>
	<test_location>
	<\test_location>
<\testname>
<testname=timer_create02>
	<description>
		Basic test for timer_create(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/timers/timer_create/timer_create02.c
	<\test_location>
<\testname>
<testname=timer_create03>
	<description>
		Test checking for basic error conditions for timer_create(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/timers/timer_create/timer_create03.c
	<\test_location>
<\testname>
<testname=timer_delete01>
	<description>
		Basic test for timer_delete(2)

	<\description>
	<test_location>
	<\test_location>
<\testname>
<testname=timer_delete02>
	<description>
		Test checking for basic error conditions for timer_delete(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/timers/timer_delete/timer_delete02.c
	<\test_location>
<\testname>
<testname=timer_settime01>
	<description>
		Basic test for timer_settime(2)

	<\description>
	<test_location>
	<\test_location>
<\testname>
<testname=timers>
	<description>
		Test checking for basic error conditions for timer_settime(2)

	<\description>
	<test_location>
		ltp/testcases/kernel/timers
	<\test_location>
<\testname>
